openref: 0.1

info:
  id: reference/supabase-kotlin
  title: Supabase Kotlin Client
  description: |

    Supabase Kotlin.

  specUrl: https://github.com/supabase/supabase/edit/master/spec/supabase_kt_v0.yml
  slugPrefix: '/'
  libraries:
    - name: 'Kotlin'
      id: 'kt'
      version: '0.0.1'

functions:
  - id: initializing
    title: 'Initializing'
    description: |
      Independently of which supabase module you are using, you will need to initialize the main client first and install the module.
      
      To create a new client, you can use the `createSupabaseClient` function.
      
      When installing a module, you can pass a block to configure it.

    examples:
      - id: initialize-client
        name: Initialize Client
        code: |
          ```kotlin
          val client = createSupabaseClient(
              supabaseUrl = "https://xyzcompany.supabase.co", 
              supabaseKey = "public-anon-key"
          ) {
              install(GoTrue)
              install(Postgrest)
          }
          ```
      - id: configure-gotrue
        name: Configure GoTrue module
        code: |
          ```kotlin
          val client = createSupabaseClient(
              supabaseUrl = "https://xyzcompany.supabase.co", 
              supabaseKey = "public-anon-key"
          ) {
              install(GoTrue) {
                  alwaysAutoRefresh = false // default: true
                  autoLoadFromStorage = false // default: true
                  //and more...
              }
          }
          ```
      - id: configure-postgrest
        name: Configure Postgrest module
        code: |
          ```kotlin
          val client = createSupabaseClient(
              supabaseUrl = "https://xyzcompany.supabase.co", 
              supabaseKey = "public-anon-key"
          ) {
              install(Postgrest) {
                  defaultSchema = "schema" // default: "public"
                  propertyConversionMethod = PropertyConversionMethod.SERIAL_NAME // default: PropertyConversionMethod.CAMEL_CASE_TO_SNAKE_CASE
              }
          }
          ```  

  - id: select
    title: 'Fetch data: select()'
    notes: |
      Perform a SELECT query on the table or view.
      - When calling a `decode` method, you have to provide a [serializable class]() as the type parameter.
      - You can provide a `Columns` object to select specific columns.
      - You can provide a [filter]() block to filter the results
    examples:
      - id: getting-your-data
        name: Getting your data
        isSpotlight: true
        code: |
          ```kotlin
          val city = client.postgrest["cities"].select().decodeSingle<City>()
          ```
      - id: selecting-specific-columns
        name: Selecting specific columns
        description: You can select specific fields from your tables.
        code: |
          ```kotlin
          val city = client.postgrest["cities"].select(columns = Columns.list("id, name")).decodeSingle<City>()
          ```
      - id: query-foreign-tables
        name: Query foreign tables
        description: If your database has foreign key relationships, you can query related tables too.
        code: |
          ```kotlin
          val country = client.postgrest["countries"]
                      .select(
                          columns = Columns.raw(
                                          """
                                          id,
                                          name,
                                          cities (
                                              id,
                                              name
                                          )
                                          """)
                      )
                      .decodeSingle<Country>()
          ```
        note: |
          What about join tables
          If you're in a situation where your tables are **NOT** directly related, but instead are joined by a _join table_,
          you can still use the `select()` method to query the related data. The PostgREST engine detects the relationship automatically.
          For more details, [follow the link](https://postgrest.org/en/latest/api.html#embedding-through-join-tables).
      - id: query-the-same-foreign-table-multiple-times
        name: Query the same foreign table multiple times
        description: |
          Sometimes you will need to query the same foreign table twice.
          In this case, you can use the name of the joined column to identify
          which join you intend to use. For convenience, you can also give an
          alias for each column. For example, if we had a shop of products,
          and we wanted to get the supplier and the purchaser at the same time
          (both in the users) table
        code: |
          ```kotlin
          val message = client.postgrest["messages"]
                      .select(columns = Columns.raw(
                                        """            
                                        content,
                                        from: sender_id(name),
                                        to: receiver_id(name)
                                        """))
                      .decodeSingle<Message>()
          ```
      - id: querying-with-count-option
        name: Querying with count option
        description: |
          You can get the number of rows by using the count option.
          Allowed values for count option are [Count.EXACT](https://postgrest.org/en/stable/api.html#exact-count), [Count.PLANNED](https://postgrest.org/en/stable/api.html#planned-count) and [Count.ESTIMATED](https://postgrest.org/en/stable/api.html#estimated-count).
        code: |
          ```kotlin
          val count = client.postgrest["countries"]
                      .select(head = true, count = Count.EXACT)
                      .count()!!
          ```
      - id: querying-json-data
        name: Querying JSON data
        description: |
          If you have data inside of a JSONB column, you can apply select
          and query filters to the data values. Postgres offers a
          [number of operators](https://www.postgresql.org/docs/current/functions-json.html)
          for querying JSON data. Also see
          [PostgREST docs](http://postgrest.org/en/v7.0.0/api.html#json-columns) for more details.
        code: |
          ```kotlin
          val user = client.postgrest["users"]
                      .select(columns = Columns.raw(
                                      """
                                      id, name
                                      address->city
                                      """)
                      .decodeSingle<User>()
          ```

  - id: insert
    title: 'Create data: insert()'
    $ref: '@supabase/postgrest-js."lib/PostgrestQueryBuilder".PostgrestQueryBuilder.insert'
    notes: |
      - When calling an `insert` method, you have to provide a [serializable value]().
      - By default, every time you run `insert()`, the client library will make a `select` to return the full record.
      This is convenient, but it can also cause problems if your policies are not configured to allow the `select` operation.
      If you are using Row Level Security and you are encountering problems, try setting the `returning` param to `Returning.MINIMAL`.
    examples:
      - id: create-a-record
        name: Create a record
        isSpotlight: true
        code: |
          ```kotlin
          val city = City(name = "The Shire", countryId = 554)
          client.postgrest["cities"].insert(city, returning = Returning.MINIMAL) //returning defaults to Returning.REPRESENTATION
          ```
      - id: bulk-create
        name: Bulk create
        description: |
          When running a bulk create, the operation is handled in a single transaction. If any of the inserts fail, all other operations are
          rolled back.
        code: |
          ```kotlin
          val theShire = City(name = "The Shire", countryId = 554)
          val rohan = City(name = "Rohan", countryId = 554)
          client.postgrest["cities"].insert(listOf(theShire, rohan), returning = Returning.MINIMAL) //returning defaults to Returning.REPRESENTATION
          ```
      - id: fetch-inserted-data
        name: Fetch inserted record
        code: |
          ```kotlin
          val theShire = City(name = "The Shire", countryId = 554)
          val rohan = City(name = "Rohan", countryId = 554)
          val result = client.postgrest["cities"].insert(listOf(theShire, rohan)).decodeList<City>()
          ```

  - id: update
    title: 'Modify data: update()'
    notes: |
      - `update()` should always be combined with a [filter] block to avoid updating all records.
      - When calling a `decode` method, you have to provide a [serializable class]() as the type parameter.
    examples:
      - id: updating-your-data
        name: Updating your data
        isSpotlight: true
        code: |
          ```kotlin
          client.postgrest["countries"].update(
              {
                 Country::name setTo "Australia"
                 //or
                 set("name", "Australia")
              }
          ) {
             Country::id eq 1
             //or
             eq("id", 1)
          }
          ```
      - id: update-a-record-and-return-it
        name: Update a record and return it
        code: |
          ```kotlin
          val newCountry = client.postgrest["countries"].update(
              {
                 Country::name setTo "Australia"
                 //or
                 set("name", "Australia")
              }
          ) {
             Country::id eq 1
             //or
             eq("id", 1)
          }.decodeSingle<Country>()
          ```
        data:
          sql: |
            ```sql
            create table
              countries (id int8 primary key, name text);

            insert into
              countries (id, name)
            values
              (1, 'Taiwan');
            ```
        response: |
          ```json
          {
            "data": [
              {
                "id": 1,
                "name": "Australia"
              }
            ],
            "status": 200,
            "statusText": "OK"
          }
          ```
        hideCodeBlock: true
      - id: updating-json-data
        name: Updating JSON data
        description: |
          Postgres offers a
          [number of operators](https://www.postgresql.org/docs/current/functions-json.html)
          for working with JSON data. Right now it is only possible to update an entire JSON document,
          but we are [working on ideas](https://github.com/PostgREST/postgrest/issues/465) for updating individual keys.
        code: |
          ```kotlin
          val address = Address(street = "Melrose Place", postcode = 90210)
          client.postgrest["users"].update(
              {
                 User::address setTo address
              }
          ) {
             User::id eq 1
             //or
             eq("address->postcode", 90210)
          }.decodeSingle<Country>()
          ```

  - id: upsert
    title: 'Upsert data: upsert()'
    $ref: '@supabase/postgrest-js."lib/PostgrestQueryBuilder".PostgrestQueryBuilder.upsert'
    notes: |
      - Primary keys should be included in the data payload in order for an update to work correctly.
      - Primary keys  must be natural, not surrogate. There are however, [workarounds](https://github.com/PostgREST/postgrest/issues/1118) for surrogate primary keys.
      - If you need to insert new data and update existing data at the same time, use [Postgres triggers](https://github.com/supabase/postgrest-js/issues/173#issuecomment-825124550).
    examples:
      - id: upsert-your-data
        name: Upsert your data
        isSpotlight: true
        code: |
          ```kotlin
          val toUpsert = Message(id = 3, message = "foo", username = "supabot")
          client.postgrest["messages"].insert(toUpsert, upsert = true)
          ```
      - id: upserting-into-tables-with-constraints
        name: Upserting into tables with constraints
        description: |
          Running the following will cause supabase to upsert data into the `users` table.
          If the username 'supabot' already exists, the `onConflict` argument tells supabase to overwrite that row
          based on the column passed into `onConflict`.
        isSpotlight: true
        code: |
          ```kotlin
          let toUpsert = User(username = "supabot")
          client.postgrest["users"].insert(toUpsert, upsert = true, onConflict = "username")                          
          ```
      - name: Return the exact number of rows
        isSpotlight: true
        code: |
          ```kotlin
          let toUpsert = User(username = "supabot")
          val count = client.postgrest["users"].insert(toUpsert, upsert = true, onConflict = "username", count = Count.EXACT).count()   
          ```

  - id: delete
    title: 'Delete data: delete()'
    $ref: '@supabase/postgrest-js."lib/PostgrestQueryBuilder".PostgrestQueryBuilder.delete'
    notes: |
      - `delete()` should always be combined with a [filter]() block to target the item(s) you wish to delete.
      - If you use `delete()` with filters and you have
        [RLS](/docs/learn/auth-deep-dive/auth-row-level-security) enabled, only
        rows visible through `SELECT` policies are deleted. Note that by default
        no rows are visible, so you need at least one `SELECT`/`ALL` policy that
        makes the rows visible.
    examples:
      - id: delete-records
        name: Delete records
        isSpotlight: true
        code: |
          ```kotlin
          client.postgrest["cities"].delete {
             City::id eq 666
             //or
             eq("id", 666)
          }      
          ```
      - id: fetch-delete-records
        name: Fetch deleted records
        code: |
          ```kotlin
          val deletedCity = client.postgrest["cities"].delete {
             City::id eq 666
             //or
             eq("id", 666)
          }.decodeSingle<City>()   
          ```
  - id: rpc
    title: 'Stored Procedures: rpc()'
    description: |
      You can call stored procedures as a "Remote Procedure Call".

      That's a fancy way of saying that you can put some logic into your database then call it from anywhere.
      It's especially useful when the logic rarely changes - like password resets and updates.
      
      - When calling specifying parameters, you have to provide a [serializable value]().
    examples:
      - id: call-a-stored-procedure
        name: Call a stored procedure
        isSpotlight: true
        description: This is an example invoking a stored procedure.
        code: |
          ```kotlin
          client.postgrest.rpc("hello_world")
          ```
      - id: with-parameters
        name: With Parameters
        code: |
          ```kotlin
          val rpcParams = City(name "The Shire")
          client.postgrest.rpc("echo_city", rpcParams)
          ```
  - id: using-filters
    title: Using Filters
    description: |
      Filters allow you to only return rows that match certain conditions.

      Filters can be used on `select()`, `update()`, and `delete()` queries.
      
      You can use two different types for applying filters:
      ```kotlin
      eq("country_id", 1)
      ```
      And using a class property:
      ```kotlin
      City::countryId eq 1
      ```
      
      As you can see on the property syntax: 
      the name of the `countryId` gets converted to `country_id`. 
      
      By default, this is done by converting camel case to snake case, but you can customize this by changing the `PropertyConversionMethod` in the Postgrest Config

      If a database function returns a table response, you can also apply filters.
    examples:
      - id: applying-filters
        name: Applying a filter block
        description: |
          Filters can be applied on any of these functions: `select()`, `update()`, `upsert()`,
          `delete()`, and `rpc()`
        code: |
          ```kotlin
          client.postgrest["cities"].select(columns = Columns.list("name, country_id")) {
              City::name eq "The Shire"
              //or
              eq("name", "The Shire")
          }      
          ```
      - id: multiple-filters
        name: Multiple filters on one column
        description: |
          Filters can be applied on any of these functions: `select()`, `update()`, `upsert()`,
          `delete()`, and `rpc()`
        code: |
          ```kotlin
          client.postgrest["cities"].select(columns = Columns.list("name, country_id")) {
              and { //when both are true
                 City::population gt 40000
                 City::population lt 700000
              }
              or { //when either one of the filters are true
                 City::name eq "London"
                 City::name eq "Berlin"
              }
          }  
          ```
      - id: filter-by-value-within-json-column
        name: Filter by values within a JSON column
        description: |
          Filters can be built up one step at a time and then executed. For example:
        data:
          sql: |
            ```sql
            create table
              users (
                id int8 primary key,
                name text,
                address jsonb
              );

            insert into
              users (id, name, address)
            values
              (1, 'Michael', '{ "postcode": 90210 }'),
              (2, 'Jane', null);
            ```
        response: |
          ```json
          {
            "data": [
              {
                "id": 1,
                "name": "Michael",
                "address": {
                  "postcode": 90210
                }
              }
            ],
            "status": 200,
            "statusText": "OK"
          }
          ```
        code: |
          ```kotlin
          client.postgrest["users"].select {
             eq("address->postcode", 90210)
          }      
          ```
      - id: filter-foreign-tables
        name: Filter Foreign Tables
        code: |
          ```kotlin
          client.postgrest["countries"].select(
                columns = Columns.raw("""
                                      name,
                                      cities!inner (
                                        name
                                      )  
                                      """)
          ) {
              eq("cities.name", "Bali")
          }      
          ```
        data:
          sql: |
            ```sql
            create table
              countries (id int8 primary key, name text);
            create table
              cities (
                id int8 primary key,
                country_id int8 not null references countries,
                name text
              );

            insert into
              countries (id, name)
            values
              (1, 'Germany'),
              (2, 'Indonesia');
            insert into
              cities (id, country_id, name)
            values
              (1, 2, 'Bali'),
              (2, 1, 'Munich');
            ```
          response: |
            ```json
            {
              "data": [
                {
                  "name": "Indonesia",
                  "cities": [
                    {
                      "name": "Bali"
                    }
                  ]
                }
              ],
              "status": 200,
              "statusText": "OK"
            }
            ```
  - id: or
    title: or()
    description: |
      Finds all rows satisfying at least one of the filters.
    notes: |
    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
          client.postgrest["countries"].select(columns = Columns.list("name")) {
              or {
                  Country::id eq 2
                  Country::name eq "Algeria"
                  //or
                  eq("id", 2)
                  eq("name", "Algeria")
              }
          }      
          ```
      - id: use-or-with-and
        name: Use `or` with `and`
        code: |
          ```kotlin
          client.postgrest["countries"].select(columns = Columns.list("name")) {
              or {
                  Country::id gt 3
                  and {
                     Country::id eq 1
                     Country::name eq "Afghanistan"
                  }
              }
          }      
          ```

  - id: not
    title: filterNot()
    description: |
      Finds all rows that don't satisfy the filter.
    notes: |
      - `.filterNot()` expects you to use the raw [PostgREST syntax](https://postgrest.org/en/stable/api.html#horizontal-filtering-rows) for the filter names and values.
    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
          client.postgrest["countries"].select {
              filterNot("name", FilterOperation.IS, "")
          }   
          ```

  - id: eq
    title: eq()
    description: |
      Finds all rows whose value on the stated `column` exactly matches the specified `value`.
    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
          client.postgrest["cities"].select(columns = Columns.list("name", "country_id")) {
              City::name eq "The Shire"
              //or
              eq("name", "The Shire")
          }      
          ```
      - id: with-update
        name: With `update()`
        code: |
          ```kotlin
          val toUpdate = City(name = "Mordor")
          client.postgrest["cities"].update(toUpdate) {
              City::name eq "San Francisco"
              //or
              eq("name", "San Francisco")
          }                 
          ```
      - id: with-delete
        name: With `delete()`
        code: |
          ```kotlin
          client.postgrest["cities"].delete {
              City::name eq "Mordor"
              //or
              eq("name", "Mordor")
          }   
          ```
      - id: with-rpc
        name: With `rpc()`
        code: |
          ```kotlin
          client.postgrest.rpc("function") {
              City::name eq "Mordor"
              //or
              eq("name", "Mordor")
          }      
          ```

  - id: neq
    title: neq()
    description: |
      Finds all rows whose value on the stated `column` doesn't match the specified `value`.
    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
          client.postgrest["cities"].select(columns = Columns.list("name", "country_id")) {
              City::name neq "The Shire"
              //or
              neq("name", "The Shire")
          }      
          ```
      - id: with-update
        name: With `update()`
        code: |
          ```kotlin
          val toUpdate = City(name = "Mordor")
          client.postgrest["cities"].update(toUpdate) {
              City::name neq "The Shire"
              //or
              neq("name", "The Shire")
          }
          ```
      - id: with-delete
        name: With `delete()`
        code: |
          ```kotlin
          client.postgrest["cities"].delete {
              City::name neq "The Shire"
              //or
              neq("name", "The Shire")
          }
          ```
      - id: with-rpc
        name: With `rpc()`
        code: |
          ```kotlin
          client.rpc("echo_all_cities") {
              neq("address->postcode", 90210)
          }      
          ```

  - id: gt
    title: gt()
    description: |
      Finds all rows whose value on the stated `column` is greater than the specified `value`.
    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
          client.postgrest["cities"].select(columns = Columns.list("name")) {
             City::countryId gt 300
             //or
             gt("country_id", 300)
          }
          ```
      - id: with-update
        name: With `update()`
        code: |
          ```kotlin
          val toUpdate = City(name = "Mordor")
          client.postgrest["cities"].update(toUpdate) {
             City::countryId gt 300
             //or
             gt("country_id", 300)
          }
          ```
      - id: with-delete
        name: With `delete()`
        code: |
          ```kotlin
          client.postgrest["cities"].delete {
             City::countryId gt 300
             //or
             gt("country_id", 300)
          }
          ```
      - id: with-rpc
        name: With `rpc()`
        code: |
          ```kotlin
          client.postgrest.rpc("echo_all_cities") {
             City::countryId gt 250
             //or
             gt("country_id", 300)
          }      
          ```

  - id: gte
    title: gte()
    description: |
      Finds all rows whose value on the stated `column` is greater than or equal to the specified `value`.
    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
          client.postgrest["cities"].select(columns = Columns.list("name")) {
             City::countryId gte 300
             //or
             gte("country_id", 300)
          }
          ```
      - id: with-update
        name: With `update()`
        code: |
          ```kotlin
          val toUpdate = City(name = "Mordor")
          client.postgrest["cities"].update(toUpdate) {
             City::countryId gte 300
             //or
             gte("country_id", 300)
          }
          ```
      - id: with-delete
        name: With `delete()`
        code: |
          ```kotlin
          client.postgrest["cities"].delete {
             City::countryId gte 300
             //or
             gte("country_id", 300)
          }
          ```
      - id: with-rpc
        name: With `rpc()`
        code: |
          ```kotlin
          client.postgrest.rpc("echo_all_cities") {
             City::countryId gte 250
             //or
             gte("country_id", 300)
          }      
          ```

  - id: lt
    title: lt()
    description: |
      Finds all rows whose value on the stated `column` is less than the specified `value`.
    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
          client.postgrest["cities"].select(columns = Columns.list("name")) {
             City::countryId lt 300
             //or
             lt("country_id", 300)
          }
          ```
      - id: with-update
        name: With `update()`
        code: |
          ```kotlin
          val toUpdate = City(name = "Mordor")
          client.postgrest["cities"].update(toUpdate) {
             City::countryId lt 300
             //or
             lt("country_id", 300)
          }
          ```
      - id: with-delete
        name: With `delete()`
        code: |
          ```kotlin
          client.postgrest["cities"].delete {
             City::countryId lt 300
             //or
             lt("country_id", 300)
          }
          ```
      - id: with-rpc
        name: With `rpc()`
        code: |
          ```kotlin
          client.postgrest.rpc("echo_all_cities") {
             City::countryId lt 250
             //or
             lt("country_id", 300)
          }      
          ```

  - id: lte
    title: lte()
    description: |
      Finds all rows whose value on the stated `column` is less than or equal to the specified `value`.
    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
          client.postgrest["cities"].select(columns = Columns.list("name")) {
             City::countryId lte 300
             //or
             lte("country_id", 300)
          }
          ```
      - id: with-update
        name: With `update()`
        code: |
          ```kotlin
          val toUpdate = City(name = "Mordor")
          client.postgrest["cities"].update(toUpdate) {
             City::countryId lte 300
             //or
             lte("country_id", 300)
          }
          ```
      - id: with-delete
        name: With `delete()`
        code: |
          ```kotlin
          client.postgrest["cities"].delete {
             City::countryId lte 300
             //or
             lte("country_id", 300)
          }
          ```
      - id: with-rpc
        name: With `rpc()`
        code: |
          ```kotlin
          client.postgrest.rpc("echo_all_cities") {
             City::countryId lte 250
             //or
             lte("country_id", 300)
          }      
          ```

  - id: like
    title: like()
    description: |
      Finds all rows whose value in the stated `column` matches the supplied `pattern` (case sensitive).
    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
          client.postgrest["cities"].select(columns = Columns.list("name")) {
             City::name like "%la%"
             //or
             like("name", "%la%")
          }      
          ```
      - id: with-update
        name: With `update()`
        code: |
          ```kotlin
          val toUpdate = City(name = "Mordor")
          client.postgrest["cities"].update(toUpdate) {
             City::name like "%la%"
             //or
             like("name", "%la%")
          }      
          ```
      - id: with-delete
        name: With `delete()`
        code: |
          ```kotlin
          client.postgrest["cities"].delete {
             City::name like "%la%"
             //or
             like("name", "%la%")
          }      
          ```
      - id: with-rpc
        name: With `rpc()`
        code: |
          ```kotlin
          client.postgrest.rpc("echo_all_cities") {
             City::name like "%la%"
             //or
             like("name", "%la%")
          }     
          ```

  - id: ilike
    title: ilike()
    description: |
      Finds all rows whose value in the stated `column` matches the supplied `pattern` (case insensitive).
    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
          client.postgrest["cities"].select(columns = Columns.list("name")) {
             City::name ilike "%la%"
             //or
             ilike("name", "%la%")
          }      
          ```
      - id: with-update
        name: With `update()`
        code: |
          ```kotlin
          val toUpdate = City(name = "Mordor")
          client.postgrest["cities"].update(toUpdate) {
             City::name ilike "%la%"
             //or
             ilike("name", "%la%")
          }      
          ```
      - id: with-delete
        name: With `delete()`
        code: |
          ```kotlin
          client.postgrest["cities"].delete {
             City::name ilike "%la%"
             //or
             ilike("name", "%la%")
          }      
          ```
      - id: with-rpc
        name: With `rpc()`
        code: |
          ```kotlin
          client.postgrest.rpc("echo_all_cities") {
             City::name ilike "%la%"
             //or
             ilike("name", "%la%")
          }     
          ```

  - id: is
    title: is_()
    description: |
      A check for exact equality (null, true, false), finds all rows whose value on the stated `column` exactly match the specified `value`.

      `is_` and `in_` filter methods are suffixed with `_` to avoid collisions with reserved keywords.
    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
          client.postgrest["cities"].select(columns = Columns.list("name")) {
             City::name isExact null
             //or
             exact("name", null)
          }      
          ```
      - id: with-update
        name: With `update()`
        code: |
          ```kotlin
          val toUpdate = City(name = "Mordor")
          client.postgrest["cities"].update(toUpdate) {
             City::name isExact null
             //or
             exact("name", null)
          }      
          ```
      - id: with-delete
        name: With `delete()`
        code: |
          ```kotlin
          client.postgrest["cities"].delete {
              City::name isExact null
             //or
             exact("name", null)
          }      
          ```
      - id: with-rpc
        name: With `rpc()`
        code: |
          ```kotlin
          client.postgrest.rpc("echo_all_cities") {
             City::name isExact null
             //or
             exact("name", null)
          }     
          ```

  - id: in
    title: in_()
    description: |
      Finds all rows whose value on the stated `column` is found on the specified `values`.
    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
          client.postgrest["cities"].select(columns = Columns.list("name")) {
             City::name isIn listOf("Rio de Janeiro", "San Francisco")
             //or
             isIn("name", listOf("Rio de Janeiro", "San Francisco"))
          }      
          ```
      - id: with-update
        name: With `update()`
        code: |
          ```kotlin
          val toUpdate = City(name = "Mordor")
          client.postgrest["cities"].update(toUpdate) {
             City::name isIn listOf("Rio de Janeiro", "San Francisco")
             //or
             isIn("name", listOf("Rio de Janeiro", "San Francisco"))
          }      
          ```
      - id: with-delete
        name: With `delete()`
        code: |
          ```kotlin
          client.postgrest["cities"].delete {
             City::name isIn listOf("Rio de Janeiro", "San Francisco")
             //or
             isIn("name", listOf("Rio de Janeiro", "San Francisco"))
          }      
          ```
      - id: with-rpc
        name: With `rpc()`
        code: |
          ```kotlin
          client.postgrest.rpc("echo_all_cities") {
             City::name isIn listOf("Rio de Janeiro", "San Francisco")
             //or
             isIn("name", listOf("Rio de Janeiro", "San Francisco"))
          }     
          ```

  - id: contains
    title: contains()
    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
          client.postgrest["cities"].select(columns = Columns.list("name")) {
             City::mainExports contains listOf("oil")
             //or
             contains("main_exports", listOf("oil"))
          }      
          ```
      - id: with-update
        name: With `update()`
        code: |
          ```kotlin
          val toUpdate = City(name = "Mordor")
          client.postgrest["cities"].update(toUpdate) {
             City::mainExports contains listOf("oil")
             //or
             contains("main_exports", listOf("oil"))
          }      
          ```
      - id: with-delete
        name: With `delete()`
        code: |
          ```kotlin
          client.postgrest["cities"].delete {
             City::mainExports contains listOf("oil")
             //or
             contains("main_exports", listOf("oil"))
          }      
          ```
      - id: with-rpc
        name: With `rpc()`
        code: |
          ```kotlin
          client.postgrest.rpc("echo_all_cities") {
             City::mainExports contains listOf("oil")
             //or
             contains("main_exports", listOf("oil"))
          }     
          ```

  - id: range-lt
    title: rangeLt()
    description: |
      Only relevant for range columns. Match only rows where every element in column is less than any element in range.
    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
            client.postgrest["reservations"].select {
               Reservation::during rangeLt ("2000-01-02 08:30" to "2000-01-02 09:30")
               //or
               rangeLt("during", "2000-01-02 08:30" to "2000-01-02 09:30") 
            }      
          ```
        data:
          sql: |
            ```sql
            create table
              reservations (
                id int8 primary key,
                room_name text,
                during tsrange
              );

            insert into
              reservations (id, room_name, during)
            values
              (1, 'Emerald', '[2000-01-01 13:00, 2000-01-01 15:00)'),
              (2, 'Topaz', '[2000-01-02 09:00, 2000-01-02 10:00)');
            ```
        response: |
          ```json
          {
            "data": [
              {
                "id": 1,
                "room_name": "Emerald",
                "during": "[\"2000-01-01 13:00:00\",\"2000-01-01 15:00:00\")"
              }
            ],
            "status": 200,
            "statusText": "OK"
          }
          ```
        description: |
          Postgres supports a number of [range
          types](https://www.postgresql.org/docs/current/rangetypes.html). You
          can filter on range columns using the string representation of range
          values.
        hideCodeBlock: true

  - id: range-gt
    title: rangeGt()
    description: |
      Only relevant for range columns. Match only rows where every element in column is greater than any element in range.

    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
            client.postgrest["reservations"].select {
               Reservation::during rangeGt ("2000-01-02 08:30" to "2000-01-02 09:30")
               //or
               rangeGt("during", "2000-01-02 08:30" to "2000-01-02 09:30") 
            }      
          ```
        data:
          sql: |
            ```sql
            create table
              reservations (
                id int8 primary key,
                room_name text,
                during tsrange
              );

            insert into
              reservations (id, room_name, during)
            values
              (1, 'Emerald', '[2000-01-01 13:00, 2000-01-01 15:00)'),
              (2, 'Topaz', '[2000-01-02 09:00, 2000-01-02 10:00)');
            ```
        response: |
          ```json
            {
              "data": [
                {
                  "id": 2,
                  "room_name": "Topaz",
                  "during": "[\"2000-01-02 09:00:00\",\"2000-01-02 10:00:00\")"
                }
              ],
              "status": 200,
              "statusText": "OK"
            }
            ```
        description: |
          Postgres supports a number of [range
          types](https://www.postgresql.org/docs/current/rangetypes.html). You
          can filter on range columns using the string representation of range
          values.
        hideCodeBlock: true

  - id: range-gte
    title: rangeGte()
    description: |
      Only relevant for range columns. Match only rows where every element in column is either contained in range or greater than any element in range.
    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
            client.postgrest["reservations"].select {
               Reservation::during rangeGte ("2000-01-02 08:30" to "2000-01-02 09:30")
               //or
               rangeGte("during", "2000-01-02 08:30" to "2000-01-02 09:30") 
            }      
          ```
        data:
          sql: |
            ```sql
            create table
              reservations (
                id int8 primary key,
                room_name text,
                during tsrange
              );

            insert into
              reservations (id, room_name, during)
            values
              (1, 'Emerald', '[2000-01-01 13:00, 2000-01-01 15:00)'),
              (2, 'Topaz', '[2000-01-02 09:00, 2000-01-02 10:00)');
            ```
        response: |
          ```json
            {
              "data": [
                {
                  "id": 2,
                  "room_name": "Topaz",
                  "during": "[\"2000-01-02 09:00:00\",\"2000-01-02 10:00:00\")"
                }
              ],
              "status": 200,
              "statusText": "OK"
            }
            ```
        description: |
          Postgres supports a number of [range
          types](https://www.postgresql.org/docs/current/rangetypes.html). You
          can filter on range columns using the string representation of range
          values.
        hideCodeBlock: true

  - id: range-lte
    title: rangeLte()
    description: |
      Only relevant for range columns. Match only rows where every element in column is either contained in range or less than any element in range.

    $ref: '@supabase/postgrest-js.PostgrestFilterBuilder.rangeLte'
    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
            client.postgrest["reservations"].select {
               Reservation::during rangeLte ("2000-01-02 08:30" to "2000-01-02 09:30")
               //or
               rangeLte("during", "2000-01-02 08:30" to "2000-01-02 09:30") 
            }      
          ```
        data:
          sql: |
            ```sql
            create table
              reservations (
                id int8 primary key,
                room_name text,
                during tsrange
              );

            insert into
              reservations (id, room_name, during)
            values
              (1, 'Emerald', '[2000-01-01 13:00, 2000-01-01 15:00)'),
              (2, 'Topaz', '[2000-01-02 09:00, 2000-01-02 10:00)');
            ```
        response: |
          ```json
            {
              "data": [
                {
                  "id": 1,
                  "room_name": "Emerald",
                  "during": "[\"2000-01-01 13:00:00\",\"2000-01-01 15:00:00\")"
                }
              ],
              "status": 200,
              "statusText": "OK"
            }
            ```
        description: |
          Postgres supports a number of [range
          types](https://www.postgresql.org/docs/current/rangetypes.html). You
          can filter on range columns using the string representation of range
          values.
        hideCodeBlock: true

  - id: range-adjacent
    title: rangeAdjacent()
    description: |
      Only relevant for range columns. Match only rows where column is mutually exclusive to range and there can be no element between the two ranges.

    examples:
      - id: with-select
        name: With `select()`
        isSpotlight: true
        code: |
          ```kotlin
            client.postgrest["reservations"].select {
               Reservation::during adjacent ("2000-01-02 08:30" to "2000-01-02 09:30")
               //or
               adjacent("during", "2000-01-02 08:30" to "2000-01-02 09:30") 
            }      
          ```
        data:
          sql: |
            ```sql
            create table
              reservations (
                id int8 primary key,
                room_name text,
                during tsrange
              );

            insert into
              reservations (id, room_name, during)
            values
              (1, 'Emerald', '[2000-01-01 13:00, 2000-01-01 15:00)'),
              (2, 'Topaz', '[2000-01-02 09:00, 2000-01-02 10:00)');
            ```
        response: |
          ```json
          {
            "data": [
              {
                "id": 1,
                "room_name": "Emerald",
                "during": "[\"2000-01-01 13:00:00\",\"2000-01-01 15:00:00\")"
              }
            ],
            "status": 200,
            "statusText": "OK"
          }
          ```

        hideCodeBlock: true

  - id: overlaps
    title: overlaps()
    $ref: '@supabase/postgrest-js.PostgrestFilterBuilder.overlaps'
    description: |
      Only relevant for array and range columns. Match only rows where column and value have an element in common.

    examples:
      - id: on-array-columns
        name: On array columns
        code: |
          ```kotlin
          client.postgrest["issues"].select(columns = Columns.list("title")) {
             Issue::tags overlaps listOf("is:closed", "severity:high")
             //or
             overlaps("tags", listOf("is:closed", "severity:high"))
          }      
          ```
        data:
          sql: |
            ```sql
            create table
              issues (
                id int8 primary key,
                title text,
                tags text[]
              );

            insert into
              issues (id, title, tags)
            values
              (1, 'Cache invalidation is not working', array['is:open', 'severity:high', 'priority:low']),
              (2, 'Use better names', array['is:open', 'severity:low', 'priority:medium']);
            ```
        response: |
          ```json
          {
            "data": [
              {
                "title": "Cache invalidation is not working"
              }
            ],
            "status": 200,
            "statusText": "OK"
          }
          ```
        hideCodeBlock: true
        isSpotlight: true
      - id: on-range-columns
        name: On range columns
        code: |
          ```kotlin
          client.postgrest["issues"].select(columns = Columns.list("title")) {
             Issue::tags overlaps listOf("is:closed", "severity:high")
             //or
             overlaps("tags", listOf("is:closed", "severity:high"))
          }      
          ```
        data:
          sql: |
            ```sql
            create table
              reservations (
                id int8 primary key,
                room_name text,
                during tsrange
              );

            insert into
              reservations (id, room_name, during)
            values
              (1, 'Emerald', '[2000-01-01 13:00, 2000-01-01 15:00)'),
              (2, 'Topaz', '[2000-01-02 09:00, 2000-01-02 10:00)');
            ```
        response: |
          ```json
          {
            "data": [
              {
                "id": 1,
                "room_name": "Emerald",
                "during": "[\"2000-01-01 13:00:00\",\"2000-01-01 15:00:00\")"
              }
            ],
            "status": 200,
            "statusText": "OK"
          }
          ```
        description: |
          Postgres supports a number of [range
          types](https://www.postgresql.org/docs/current/rangetypes.html). You
          can filter on range columns using the string representation of range
          values.
        hideCodeBlock: true

  - id: text-search
    title: textSearch()
    description: |
      Only relevant for text and tsvector columns. Match only rows where `column` matches the query string in `query`.

      For more information, see [Postgres full text search](https://supabase.com/docs/guides/database/full-text-search).
    examples:
      - id: text-search
        name: Text search
        code: |
          ```kotlin
          client.postgrest["quotes"].select(columns = Columns.list("catchphrase")) {
             textSearch(column = "catchphrase", query = "'fat' & 'cat'", config = "english", type = TextSearchType.YOUR_TYPE)
          }
          ```
      - id: basic-normalization
        name: Basic normalization
        description: Uses PostgreSQL's `plainto_tsquery` function.
        code: |
          ```kotlin
          client.postgrest["quotes"].select(columns = Columns.list("catchphrase")) {
             textSearch(column = "catchphrase", query = "'fat' & 'cat'", config = "english", type = TextSearchType.PLAINTO)
          }
          ```
      - id: full-normalization
        name: Full normalization
        description: Uses PostgreSQL's `phraseto_tsquery` function.
        code: |
          ```kotlin
          client.postgrest["quotes"].select(columns = Columns.list("catchphrase")) {
             textSearch(column = "catchphrase", query = "'fat' & 'cat'", config = "english", type = TextSearchType.PHRASETO)
          }
          ```
      - id: web-search
        name: Websearch
        description: |
          Uses PostgreSQL's `websearch_to_tsquery` function.
          This function will never raise syntax errors, which makes it possible to use raw user-supplied input for search, and can be used
          with advanced operators.

          - `unquoted text`: text not inside quote marks will be converted to terms separated by & operators, as if processed by plainto_tsquery.
          - `"quoted text"`: text inside quote marks will be converted to terms separated by <-> operators, as if processed by phraseto_tsquery.
          - `OR`: the word “or” will be converted to the | operator.
          - `-`: a dash will be converted to the ! operator.

        code: |
          ```kotlin
          client.postgrest["quotes"].select(columns = Columns.list("catchphrase")) {
             textSearch(column = "catchphrase", query = "'fat' & 'cat'", config = "english", type = TextSearchType.WEBSEARCH)
          }
          ```

  - id: filter
    title: filter()
    $ref: '@supabase/postgrest-js.PostgrestFilterBuilder.filter'
    notes: |
      filter() expects you to use the raw PostgREST syntax for the filter values.
    examples:
      - id: with-select
        name: With `select()`
        code: |
          ```kotlin
          client.postgrest["countries"].select {
             filter(column = "name", operator = FilterOperator.IN, value = "('Algeria', 'Japan')")
          }      
          ```
        data:
          sql: |
            ```sql
            create table
              countries (id int8 primary key, name text);

            insert into
              countries (id, name)
            values
              (1, 'Afghanistan'),
              (2, 'Albania'),
              (3, 'Algeria');
            ```
        response: |
          ```json
          {
            "data": [
              {
                "id": 3,
                "name": "Algeria"
              }
            ],
            "status": 200,
            "statusText": "OK"
          }
          ```
        hideCodeBlock: true
        isSpotlight: true
      - id: on-a-foreign-table
        name: On a foreign table
        code: |
          ```kotlin
          client.postgrest["countries"].select(
             columns = Columns.raw("""
                                   name,
                                   cities!inner (
                                     name
                                   )
                                   """)
          ) {
             filter(column = "cities.name", operator = FilterOperator.EQ, value = "Bali")
          }        
          ```
        data:
          sql: |
            ```sql
            create table
              countries (id int8 primary key, name text);
            create table
              cities (
                id int8 primary key,
                country_id int8 not null references countries,
                name text
              );

            insert into
              countries (id, name)
            values
              (1, 'Germany'),
              (2, 'Indonesia');
            insert into
              cities (id, country_id, name)
            values
              (1, 2, 'Bali'),
              (2, 1, 'Munich');
            ```
        response: |
          ```json
          {
            "data": [
              {
                "name": "Indonesia",
                "cities": [
                  {
                    "name": "Bali"
                  }
                ]
              }
            ],
            "status": 200,
            "statusText": "OK"
          }
          ```
        hideCodeBlock: true
  - id: order
    title: order()
    description: |
      Order the query result by column.
    $ref: '@supabase/postgrest-js.PostgrestTransformBuilder.order'
    examples:
      - id: with-select
        name: With `select()`
        code: |
          ```kotlin
          client.postgrest["countries"].select(columns = Columns.list("id", "name")) {
             order(column = "id", order = Order.ASCENDING)
          }
          ```
        data:
          sql: |
            ```sql
            create table
              countries (id int8 primary key, name text);

            insert into
              countries (id, name)
            values
              (1, 'Afghanistan'),
              (2, 'Albania'),
              (3, 'Algeria');
            ```
        response: |
          ```json
          {
            "data": [
              {
                "id": 3,
                "name": "Algeria"
              },
              {
                "id": 2,
                "name": "Albania"
              },
              {
                "id": 1,
                "name": "Afghanistan"
              }
            ],
            "status": 200,
            "statusText": "OK"
          }
          ```
        hideCodeBlock: true
        isSpotlight: true
      - id: on-a-foreign-table
        name: On a foreign table
        code: |
          ```kotlin
          client.postgrest["countries"].select(
              columns = Columns.raw(
                  """
                              name,
                              cities (
                                name
                              )
                        """
              )
          ) {
              order(column = "id", order = Order.ASCENDING, foreignTable = "cities")
          }
            ```
        data:
          sql: |
            ```sql
            create table
              countries (id int8 primary key, name text);
            create table
              cities (
                id int8 primary key,
                country_id int8 not null references countries,
                name text
              );

            insert into
              countries (id, name)
            values
              (1, 'United States'),
              (2, 'Vanuatu');
            insert into
              cities (id, country_id, name)
            values
              (1, 1, 'Atlanta'),
              (2, 1, 'New York City');
            ```
        response: |
          ```json
          {
            "data": [
              {
                "name": "United States",
                "cities": [
                  {
                    "name": "New York City"
                  },
                  {
                    "name": "Atlanta"
                  }
                ]
              },
              {
                "name": "Vanuatu",
                "cities": []
              }
            ],
            "status": 200,
            "statusText": "OK"
          }
          ```
        description: |
          Ordering on foreign tables doesn't affect the ordering of
          the parent table.
        hideCodeBlock: true

  - id: limit
    title: limit()
    description: |
      Limit the query result by count.
    $ref: '@supabase/postgrest-js.PostgrestTransformBuilder.limit'
    examples:
      - id: with-select
        name: With `select()`
        code: |
          ```kotlin
          client.postgrest["countries"].select {
              limit(count = 20)
          }
          ```
        data:
          sql: |
            ```sql
            create table
              countries (id int8 primary key, name text);

            insert into
              countries (id, name)
            values
              (1, 'Afghanistan'),
              (2, 'Albania'),
              (3, 'Algeria');
            ```
        response: |
          ```json
          {
            "data": [
              {
                "name": "Afghanistan"
              }
            ],
            "status": 200,
            "statusText": "OK"
          }
          ```
        hideCodeBlock: true
        isSpotlight: true
      - id: on-a-foreign-table
        name: On a foreign table
        code: |
          ```kotlin
          client.postgrest["countries"].select(
              columns = Columns.raw(
                  """
                              name,
                              cities (
                                name
                              )
                        """
              )
          ) {
              limit(count = 20, foreignTable = "cities")
          }
          ```
        data:
          sql: |
            ```sql
            create table
              countries (id int8 primary key, name text);
            create table
              cities (
                id int8 primary key,
                country_id int8 not null references countries,
                name text
              );

            insert into
              countries (id, name)
            values
              (1, 'United States');
            insert into
              cities (id, country_id, name)
            values
              (1, 1, 'Atlanta'),
              (2, 1, 'New York City');
            ```
        response: |
          ```json
          {
            "data": [
              {
                "name": "United States",
                "cities": [
                  {
                    "name": "Atlanta"
                  }
                ]
              }
            ],
            "status": 200,
            "statusText": "OK"
          }
          ```
        hideCodeBlock: true
  - id: range
    title: range()
    description: |
      Limit the query result by from and to inclusively.
    examples:
      - id: with-select
        name: With `select()`
        code: |
          ```kotlin
          client.postgrest["countries"].select {
              range(1L..5L)
          }
          ```
        data:
          sql: |
            ```sql
            create table
              countries (id int8 primary key, name text);

            insert into
              countries (id, name)
            values
              (1, 'Afghanistan'),
              (2, 'Albania'),
              (3, 'Algeria');
            ```
        response: |
          ```json
          {
            "data": [
              {
                "name": "Afghanistan"
              },
              {
                "name": "Albania"
              }
            ],
            "status": 200,
            "statusText": "OK"
          }
          ```
        hideCodeBlock: true
        isSpotlight: true
  - id: auth-api
    title: 'Overview'
    notes: |
      - The auth methods can be accessed via the Supabase GoTrue Auth client.
    examples:
      - id: create-auth-client
        name: Create gotrue client
        isSpotlight: true
        code: |
          ```kotlin
          val client = createSupabaseClient(supabaseURL = "https://xyzcompany.supabase.co'", supabaseKey = "public-anon-key") { ... }
          val gotrue = client.gotrue
          ```
  - id: sign-up
    title: 'signUp()'
    $ref: '@supabase/gotrue-js.GoTrueClient.signUp'
    notes: |
      - By default, the user needs to verify their email address before logging in. To turn this off, disable **Confirm email** in [your project](https://app.supabase.com/project/_/auth/providers).
      - **Confirm email** determines if users need to confirm their email address after signing up.
        - If **Confirm email** is enabled, the return value is null, but the session is not.
        - If **Confirm email** is disabled, the return value is the user but the session is null.
      - When the user confirms their email address, they are redirected to the [`SITE_URL`](https://supabase.com/docs/reference/auth/config#site_url) by default. You can modify your `SITE_URL` or add additional redirect URLs in [your project](https://app.supabase.com/project/_/auth/url-configuration).
      - If signUpWith() is called for an existing confirmed user:
          - If **Confirm email** is enabled in [your project](https://app.supabase.com/project/_/auth/providers), an obfuscated/fake user object is returned.
          - If **Confirm email** is disabled, the error message, `User already registered` is returned.
    examples:
      - id: sign-up
        name: Sign up with email
        isSpotlight: true
        code: |
          ```kotlin
          val user = client.gotrue.signUpWith(Email) {
              email = "example@email.com" 
              password = "example-password"
          }
          ```
      - id: sign-up
        name: Sign up with a phone number
        isSpotlight: true
        code: |
          ```kotlin
          val user = client.gotrue.signUpWith(Phone) {
              phoneNumber = "+4912345679" 
              password = "example-password"
          }
          ```   
      - id: sign-up-with-additional-user-metadata
        name: Sign up with additional user metadata
        isSpotlight: false
        code: |
          ```kotlin
          val user = client.gotrue.signUpWith(Email) {
              email = "example@email.com" 
              password = "example-password"
              data = buildJsonObject {
                 put("first_name", "John")
                 put("age", 24)
              }
          }                     
          ```
      - id: sign-up-with-redirect
        name: Sign up with a redirect URL
        description: |
          - See [redirect URLs and wildcards](/docs/guides/auth/overview#redirect-urls-and-wildcards) to add additional redirect URLs to your project.
        code: |
          ```kotlin
          val user = client.gotrue.signUpWith(Email, redirectUrl = "https://example.com") {
              email = "example@email.com" 
              password = "example-password"
          }
          ```
  - id: sign-in-with-password
    title: 'loginWith()'
    $ref: '@supabase/gotrue-js.GoTrueClient.signInWithPassword'
    notes: |
      - Requires either an email and password or a phone number and password.
    examples:
      - id: sign-in-with-email-and-password
        name: Sign in with email and password
        isSpotlight: true
        code: |
          ```kotlin
          client.gotrue.loginWith(Email) {
              email = "example@email.com" 
              password = "example-password"
          }
          ```
      - id: sign-in-with-phone-and-password
        name: Sign in with phone and password
        isSpotlight: false
        code: |
          ```kotlin
          client.gotrue.loginWith(Phone) {
              phoneNumber = "+4912345679" 
              password = "example-password"
          }
          ```  
  - id: sign-in-with-otp
    title: 'sendOtpTo()'
    $ref: '@supabase/gotrue-js.GoTrueClient.signInWithOtp'
    notes: |
      - Requires either an email or phone number.
      - This method is used for passwordless sign-ins where a OTP is sent to the user's email or phone number.
      - If the user doesn't exist, `sendOtpTo()` will signup the user instead. To restrict this behavior, you can set `createUser` to `false`.
      - If you're using an email, you can configure whether you want the user to receive a magiclink or a OTP.
      - If you're using phone, you can configure whether you want the user to receive a OTP.
      - The magic link's destination URL is determined by the [`SITE_URL`](/docs/reference/auth/config#site_url).
      - See [redirect URLs and wildcards](/docs/guides/auth/overview#redirect-urls-and-wildcards) to add additional redirect URLs to your project.
      - Magic links and OTPs share the same implementation. To send users a one-time code instead of a magic link, [modify the magic link email template](https://app.supabase.com/project/_/auth/templates) to include `{{ .Token }}` instead of `{{ .ConfirmationURL }}`.
    examples:
      - id: sign-in-with-email
        name: Sign in with email
        isSpotlight: true
        description: The user will be sent an email which contains either a magiclink or a OTP or both. By default, a given user can only request a OTP once every 60 seconds.
        code: |
          ```kotlin
          client.gotrue.sendOtpTo(Email) {
              email = "example@email.com" 
          }
          ```  
      - id: sign-in-with-sms-otp
        name: Sign in with SMS OTP
        isSpotlight: false
        description: The user will be sent a SMS which contains a OTP. By default, a given user can only request a OTP once every 60 seconds.
        code: |
          ```kotlin
          client.gotrue.sendOtpTo(Phone) {
              phoneNumber = "+4912345679" 
          }
          ```
  - id: sign-in-with-oauth
    title: 'loginWith(OAuthProvider)'
    $ref: '@supabase/gotrue-js.GoTrueClient.signInWithOAuth'
    notes: |
      - This method is used for signing in using a third-party provider.
      - Supabase supports many different [third-party providers](https://supabase.com/docs/guides/auth#providers).
      - supabase-kt has default platform implementations: HTTP Callback Server on Desktop, [deep links](https://developer.android.com/training/app-links/deep-linking) on Android, [url schemes](https://developer.apple.com/documentation/xcode/defining-a-custom-url-scheme-for-your-app) on IOS and the website on JS
        - To enable deeplinking/url scheme support on Android/IOS set the `host` and the `scheme` in the GoTrue Config and call `client.handleDeeplinks(intent)` (Android) and `client.handleDeeplinks(url)` (IOS) on startup
    examples:
      - id: sign-in-using-a-third-party-provider
        name: Sign in using a third-party provider
        isSpotlight: true
        code: |
          ```kotlin
          client.gotrue.loginWith(Github)
          ```
      - id: sign-in-using-a-third-party-provider with scopes
        name: Sign in using a third-party provider with scopes
        isSpotlight: true
        code: |
          ```kotlin
          client.gotrue.loginWith(Github) {
              scopes.add("email")
          }
          ```

      - id: sign-in-using-a-third-party-provider-with-redirect
        name: Create a custom url
        isSpotlight: false
        description: |
          - When the third-party provider successfully authenticates the user, the provider redirects the user to the URL specified in the `redirectUrl` parameter. This parameter defaults to the [`SITE_URL`](/docs/reference/auth/config#site_url). It does not redirect the user immediately after invoking this method.
          - See [redirect URLs and wildcards](/docs/guides/auth/overview#redirect-urls-and-wildcards) to add additional redirect URLs to your project.
          - oAuthUrl() provides the URL which needs to be opened in a browser.
          - The redirectTo URL needs to be setup correctly in your project under Authentication -> URL Configuration -> Redirect URLs.
          - To see how you can use a custom in-app browser on Android, check our [demo](https://github.com/supabase-community/supabase-kt/tree/development/demos/android-login) on GitHub.
        code: |
          ```kotlin
          val url = client.gotrue.oAuthUrl(Github, redirectUrl = "https://example.com")
          ```
      - id: sign-in-with-scopes
        name: Create a custom url with scopes
        isSpotlight: false
        description: |
          If you need additional data from an OAuth provider, you can include a space-separated list of scopes in your request to get back an OAuth provider token.
          You may also need to specify the scopes in the provider's OAuth app settings, depending on the provider. The list of scopes will be documented by the third-party provider you are using and specifying scopes will enable you to use the OAuth provider token to call additional APIs supported by the third-party provider to get more information.
        code: |
          ```kotlin
          val url = client.gotrue.oAuthUrl(Github, redirectUrl = "https://example.com") {
              scopes.add("email")
          }
          ```
  - id: sign-out
    title: 'logout()'
    $ref: '@supabase/gotrue-js.GoTrueClient.signOut'
    notes: |
      - In order to use the `logout()` method, the user needs to be signed in first.
    examples:
      - id: sign-out
        name: Sign out
        isSpotlight: true
        code: |
          ```js
          client.gotrue.logout()
          ```
  - id: verify-otp
    title: 'Verify OTPs'
    $ref: '@supabase/gotrue-js.GoTrueClient.verifyOtp'
    examples:
      - id: verify-email-otp(otp)
        name: Verify an Email OTP
        isSpotlight: true
        code: |
          ```kotlin
          client.gotrue.verifyEmailOtp(type = OtpType.Email.INVITE, email = "example@email.com", token = "token")
          ```
      - id: verify-phone-otp(otp)
        name: Verify an Phone OTP
        isSpotlight: false
        code: |
          ```kotlin
          client.gotrue.verifyPhoneOtp(type = OtpType.Phone.SMS, phoneNumber = "+491234567", token = "token")
          ```
  - id: get-session
    title: 'Get current session'
    $ref: '@supabase/gotrue-js.GoTrueClient.getSession'
    examples:
      - id: get-the-session-data
        name: Get the session data
        isSpotlight: true
        code: |
          ```kotlin
          val session = client.gotrue.currentSessionOrNull()
          ```
  - id: get-user
    title: 'getUser()'
    $ref: '@supabase/gotrue-js.GoTrueClient.getUser'
    description: |
      - This method gets the user object from the current session.
      - Fetches the user object from the database instead of local session.
      - Should be used only when you require the most current user data. For faster results, `getCurrentSessionOrNull()?.user` is recommended.
    examples:
      - id: get-the-logged-in-user-with-the-current-existing-session
        name: Get the logged in user with the current existing session
        isSpotlight: true
        code: |
          ```kotlin
          val user = client.gotrue.retrieveUserForCurrentSession()
          ```
  - id: update-user
    title: 'modifyUser()'
    $ref: '@supabase/gotrue-js.GoTrueClient.updateUser'
    notes: |
      - In order to use the `modifyUser()` method, the user needs to be signed in first.
      - By default, email updates sends a confirmation link to both the user's current and new email.
      To only send a confirmation link to the user's new email, disable **Secure email change** in your project's [email auth provider settings](https://app.supabase.com/project/_/auth/providers).
    examples:
      - id: update-the-email-for-an-authenticated-user
        name: Update the email for an authenticated user
        description: Sends a "Confirm Email Change" email to the new email address.
        isSpotlight: false
        code: |
          ```kotlin
          val user = client.gotrue.modifyUser(Email) {
             email = "newEmail@email.com"
          }
          ```
      - id: update-the-password-for-an-authenticated-user
        name: Update the password for an authenticated user
        isSpotlight: false
        code: |
          ```kotlin
          val user = client.gotrue.modifyUser(Email) {
             password = "secretPassword"
          }
          ```
      - id: update-the-users-metadata
        name: Update the user's metadata
        isSpotlight: true
        code: |
          ```kotlin
          val user = client.gotrue.modifyUser(Email, buildJsonObject { 
             put("name", "John")
          })
          ```
  - id: set-session
    title: 'importSession()'
    $ref: '@supabase/gotrue-js.GoTrueClient.setSession'
    notes: |
      - `importSession()` takes in a UserSession.
      - [Refresh token rotation](/docs/reference/auth/config#refresh_token_rotation_enabled) is enabled by default on all projects to guard against replay attacks.
      - You can configure the [`REFRESH_TOKEN_REUSE_INTERVAL`](https://supabase.com/docs/reference/auth/config#refresh_token_reuse_interval) which provides a short window in which the same refresh token can be used multiple times in the event of concurrency or offline issues.
    examples:
      - id: refresh-the-session
        name: Set local session
        description: Sets the local session from refresh_token and returns current session or an error if the refresh_token is invalid.
        isSpotlight: true
        code: |
          ```kotlin
          client.gotrue.importSession(UserSession(accessToken = "token", refreshToken = "refresh", expiresIn = 2000, tokenType = "Bearer", user = null))
          ```
  - id: refresh-session
    title: 'refreshSession()'
    $ref: '@supabase/gotrue-js.GoTrueClient.refreshSession'
    notes: |
      - This method will refresh the session whether the current one is expired or not.
    examples:
      - id: refresh-current-session
        name: Refresh current session
        isSpotlight: true
        code: |
          ```kotlin
          val session = client.gotrue.refreshCurrentSession()
          ```
      - id: refresh-session-using-the-current-session
        name: Refresh session using the refresh token
        isSpotlight: true
        code: |
          ```kotlin
          val session = client.gotrue.refreshSession(refreshToken = "refreshToken")
          ```
  - id: on-auth-state-change
    title: 'sessionStatus'
    $ref: '@supabase/gotrue-js.GoTrueClient.onAuthStateChange'
    notes: |
      - Types of statuses: `NotAuthenticated`, `LoadingFromStorage`, `NetworkError`, `Authenticated(sesssion)`

    examples:
      - id: listen-to-auth-changes
        name: Listen to auth changes
        isSpotlight: true
        code: |
          ```kotlin
          client.gotrue.sessionStatus.collect {
              when(it) {
                  is SessionStatus.Authenticated -> println(it.session.user)
                  SessionStatus.LoadingFromStorage -> println("Loading from storage")
                  SessionStatus.NetworkError -> println("Network error")
                  SessionStatus.NotAuthenticated -> println("Not authenticated")
              }
          }
          ```
  - id: invoke
    title: 'invoke()'
    description: |
      Invokes a Supabase Function. See the [guide](/docs/guides/functions) for details on writing Functions.
    notes: |
      - Requires an Authorization header.
    examples:
      - id: basic-invocation
        name: Basic invocation.
        isSpotlight: true
        code: |
          ```kotlin
          client.functions.invoke("function_name")
          ```
      - id: basic-invocation-with-body
        name: Basic invocation with body.
        isSpotlight: true
        code: |
          ```kotlin
          client.functions.invoke("function_name", buildJsonObject {
             put("foo", "bar")
          })
          ```
      - id: reuse-function
        name: Reuse function by saving it to a variable
        isSpotlight: true
        code: |
          ```kotlin
          val function = client.functions.buildEdgeFunction("function")
          //invoke it:
          function()
          //invoke it with a body:
          function(body)
          ```    
  - id: subscribe
    description: |
      Subscribe to realtime changes in your database.
    title: 'on().subscribe()'
    notes: |
      - Realtime is disabled by default for new Projects for better database performance and security. You can turn it on by [managing replication](/docs/guides/database/api#managing-realtime).
      - If you want to receive the "previous" data for updates and deletes, you will need to set `REPLICA IDENTITY` to `FULL`, like this: `ALTER TABLE your_table REPLICA IDENTITY FULL;`
    examples:
      - id: connect-to-realtime-client
        name: Connect to Realtime 
        isSpotlight: true
        code: |
          ```kotlin
          client.realtime.connect()
          ```
      - id: liste-to-broadcasts
        name: Listen to broadcasts
        code: |
          ```kotlin
          @Serializable
          data class Message(val content: String, val sender: String)
          
          val channel = client.realtime.createChannel("channelId") {
              //optional config
          }
          
          val broadcastFlow = channel.broadcastFlow<Message>(event = "message")
      
          //in a new coroutine (or use Flow.onEach().launchIn(scope)):
          broadcastFlow.collect { //it: Message
              println(it)
          }
          
          channel.join(blockUntilJoined = true)
          
          channel.broadcast(event = "message", Message("I joined!", "John"))
          ```   
      - id: listen-to-presence-updates
        name: Listen to presence updates
        code: | 
          ```kotlin
          @Serializable
          data class PresenceState(val username: String)
          
          val connectedUsers = mutableSetOf<PresenceState>()
          val channel = client.realtime.createChannel("channelId") {
              //optional config
          }
      
          val presenceChangeFlow = channel.presenceChangeFlow()
          
          //in a new coroutine (or use Flow.onEach().launchIn(scope)):
          presenceChangeFlow.collect {
              connectedUsers += it.decodeJoinsAs<PresenceState>()
              connectedUsers -= it.decodeLeavesAs<PresenceState>()
          }
          
          channel.join(blockUntilJoined = true)
          //send own state
          channel.track(PresenceState(username = "John"))    
      - id: listen-to-all-database-changes
        name: Listen to all database changes
        code: |
          ```kotlin
          val channel = client.realtime.createChannel("channelId") {
              //optional config
          }
          val changeFlow = channel.postgresChangeFlow<PostgresAction>(schema = "public")
          
          //in a new coroutine (or use Flow.onEach().launchIn(scope)):
          changeFlow.collect {
              when(it) {
                  is PostgresAction.Delete -> println("Deleted: ${it.oldRecord}")
                  is PostgresAction.Insert -> println("Inserted: ${it.record}")
                  is PostgresAction.Select -> println("Selected: ${it.record}")
                  is PostgresAction.Update -> println("Updated: ${it.oldRecord} with ${it.record}")
              }
          }
          
          channel.join()
          ```
      - id: listen-to-a-specific-table
        name: Listen to a specific table
        code: |
          ```kotlin
          val channel = client.realtime.createChannel("channelId") {
              //optional config
          }
          val changeFlow = channel.postgresChangeFlow<PostgresAction>(schema = "public") {
              table = "users"
          }
          
          //in a new coroutine (or use Flow.onEach().launchIn(scope)):
          changeFlow.collect {
              when(it) {
                  is PostgresAction.Delete -> println("Deleted: ${it.oldRecord}")
                  is PostgresAction.Insert -> println("Inserted: ${it.record}")
                  is PostgresAction.Select -> println("Selected: ${it.record}")
                  is PostgresAction.Update -> println("Updated: ${it.oldRecord} with ${it.record}")
              }
          }
          
          channel.join()
          ```
      - id: listen-to-inserts
        name: Listen to inserts
        code: |
          ```kotlin
          val channel = client.realtime.createChannel("channelId") {
              //optional config
          }
          val changeFlow = channel.postgresChangeFlow<PostgresAction.Insert>(schema = "public") {
              table = "users"
          }
      
          //in a new coroutine (or use Flow.onEach().launchIn(scope)):
          changeFlow.collect {
              println(it.record)
          }
      
          channel.join()
          ```
      - id: listen-to-updates
        name: Listen to updates
        description: |
          By default, Supabase will send only the updated record. If you want to receive the previous values as well you can
          enable full replication for the table you are listening too:

          ```sql
          alter table "your_table" replica identity full;
          ```
        code: |
          ```kotlin
          val channel = client.realtime.createChannel("channelId") {
              //optional config
          }
          val changeFlow = channel.postgresChangeFlow<PostgresAction.Update>(schema = "public") {
              table = "users"
          }
      
          //in a new coroutine (or use Flow.onEach().launchIn(scope)):
          changeFlow.collect {
              println(it.record)
              println(it.oldRecord)
          }
      
          channel.join()
          ```
      - id: listen-to-deletes
        name: Listen to deletes
        description: |
          By default, Supabase does not send deleted records. If you want to receive the deleted record you can
          enable full replication for the table you are listening too:

          ```sql
          alter table "your_table" replica identity full;
          ```
        code: |
          ```kotlin
          val channel = client.realtime.createChannel("channelId") {
              //optional config
          }
          val changeFlow = channel.postgresChangeFlow<PostgresAction.Delete>(schema = "public") {
              table = "users"
          }
      
          //in a new coroutine (or use Flow.onEach().launchIn(scope)):
          changeFlow.collect {
              println(it.oldRecord)
          }
      
          channel.join()
          ```
      - id: listening-to-row-level-changes
        name: Listen to row level changes
        description: You can listen to individual rows using the format `{table}:{col}=eq.{val}` - where `{col}` is the column name, and `{val}` is the value which you want to match.
        code: |
          ```kotlin
          val channel = client.realtime.createChannel("channelId") {
             //optional config
          }
          val changeFlow = channel.postgresChangeFlow<PostgresAction.Delete>(schema = "public") {
              table = "users"
              filter = "id.eq.1"
          }
      
          //in a new coroutine:
          changeFlow.collect {
              println(it.oldRecord)
          }
      
          channel.join()
          ```

  - id: remove-channel
    description: |
      Unsubscribes and removes Realtime channel from Realtime client.
    title: 'removeChannel()'
    notes: |
      - Removing a channel is a great way to maintain the performance of your project's Realtime service as well as your database if you're listening to Postgres changes.
      - Supabase will automatically handle cleanup 30 seconds after a client is disconnected, but unused channels may cause degradation as more clients are simultaneously subscribed.
    examples:
      - id: removes-a-channel
        name: Remove a channel
        isSpotlight: true
        code: |
          ```kotlin
          val channel = client.realtime.createChannel("channelId") {
              //optional config
          }
          //...
          client.realtime.removeChannel(channel)
          ```
      - id: unsubscribe-channel
        name: Unsubscribe from a channel
        isSpotlight: true
        code: |
          ```kotlin
          val channel = client.realtime.createChannel("channelId") {
              //optional config
          }
          //...
          channel.leave()
          ```
  - id: list-buckets
    title: listBuckets()
    $ref: '@supabase/storage-js.packages/StorageBucketApi.default.listBuckets'
    notes: |
      - RLS policy permissions required:
        - `buckets` table permissions: `select`
        - `objects` table permissions: none
      - Refer to the [Storage guide](/docs/guides/storage#access-control) on how access control works
    examples:
      - id: list-buckets
        name: List buckets
        isSpotlight: true
        code: |
          ```kotlin
          val buckets = client.storage.retrieveBuckets()
          ```

  - id: get-bucket
    title: getBucket()
    $ref: '@supabase/storage-js.packages/StorageBucketApi.default.getBucket'
    notes: |
      - RLS policy permissions required:
        - `buckets` table permissions: `select`
        - `objects` table permissions: none
      - Refer to the [Storage guide](/docs/guides/storage#access-control) on how access control works
    examples:
      - id: get-bucket
        name: Get bucket
        isSpotlight: true
        code: |
          ```kotlin
          val bucket = client.storage.retrieveBucketById(bucketId = "avatars")
          ```

  - id: create-bucket
    title: createBucket()
    $ref: '@supabase/storage-js.packages/StorageBucketApi.default.createBucket'
    notes: |
      - RLS policy permissions required:
        - `buckets` table permissions: `insert`
        - `objects` table permissions: none
      - Refer to the [Storage guide](/docs/guides/storage#access-control) on how access control works
    examples:
      - id: create-bucket
        name: Create bucket
        isSpotlight: true
        code: |
          ```kotlin
          client.storage.createBucket(name = "icons", id = "icons") {
              public = true
              fileSizeLimit = 5.megabytes
          }
          ```

  - id: empty-bucket
    title: emptyBucket()
    $ref: '@supabase/storage-js.packages/StorageBucketApi.default.emptyBucket'
    notes: |
      - RLS policy permissions required:
        - `buckets` table permissions: `select`
        - `objects` table permissions: `select` and `delete`
      - Refer to the [Storage guide](/docs/guides/storage#access-control) on how access control works
    examples:
      - id: empty-bucket
        name: Empty bucket
        isSpotlight: true
        code: |
          ```kotlin
          client.storage.emptyBucket(bucketId = "icons")
          ```
  - id: delete-bucket
    title: deleteBucket()
    $ref: '@supabase/storage-js.packages/StorageBucketApi.default.deleteBucket'
    notes: |
      - RLS policy permissions required:
        - `buckets` table permissions: `select` and `delete`
        - `objects` table permissions: none
      - Refer to the [Storage guide](/docs/guides/storage#access-control) on how access control works
    examples:
      - id: delete-bucket
        name: Delete bucket
        isSpotlight: true
        code: |
          ```kotlin
          client.storage.deleteBucket(bucketId = "icons")
          ```

  - id: from-upload
    title: from.upload()
    $ref: '@supabase/storage-js.packages/StorageFileApi.default.upload'
    notes: |
      - RLS policy permissions required:
        - `buckets` table permissions: none
        - `objects` table permissions: `insert`
      - Refer to the [Storage guide](/docs/guides/storage#access-control) on how access control works
    examples:
      - id: upload-file
        name: Upload file
        isSpotlight: true
        code: |
          ```kotlin
          val bucket = client.storage["avatars"]
          bucket.upload("myIcon.png", byteArray, upsert = false)
          //on JVM you can use java.io.File
          bucket.upload("myIcon.png", file, upsert = false)
          ```
      - id: upload-file-with-progress
        name: Upload file with progress
        isSpotlight: true
        code: |
          ```kotlin
          val bucket = client.storage["avatars"]
          bucket.uploadAsFlow("test.png", byteArrayOf()).collect {
              when(it) {
                  is UploadStatus.Progress -> println("Progress: ${it.totalBytesSend.toFloat() / it.contentLength * 100}%")
                  is UploadStatus.Success -> println("Success")
              }
          }
          ```    
      - id: create-resumable-upload
        name: Create resumable upload
        isSpotlight: true
        code: |
          ```kotlin
          val bucket = client.storage["avatars"]
          val upload = bucket.resumable.createOrContinueUpload("icon.png", File("icon.png"))
          //start or continue uploading
          upload.startOrResumeUploading()
      
          //pause uploading
          upload.pause()
      
          //cancel uploading
          upload.cancel()
      
          //listen to upload status
          upload.stateFlow.collect {
              println("Progress: ${it.progress * 100}%")
              println("Paused: ${it.paused}")
              println("Is done: ${it.isDone}")
          }
          ```   
      - id: continue-previous-upload
        name: Continue previous uploads
        isSpotlight: true
        code: |
          ```kotlin
          val bucket = client.storage["avatars"]
          bucket.resumable.continuePreviousFileUploads().map { it.await() }.forEach { upload ->
              upload.startOrResumeUploading()
          }
          ```          

  - id: from-update
    title: from.update()
    $ref: '@supabase/storage-js.packages/StorageFileApi.default.update'
    notes: |
      - RLS policy permissions required:
        - `buckets` table permissions: none
        - `objects` table permissions: `update` and `select`
      - Refer to the [Storage guide](/docs/guides/storage#access-control) on how access control works
    examples:
      - id: update-file
        name: Update file
        isSpotlight: true
        code: |
          ```kotlin
          val bucket = client.storage["avatars"]
          bucket.update("myIcon.png", byteArray, upsert = false)
          //on JVM you can use java.io.File
          bucket.update("myIcon.png", file, upsert = false)
          ```

  - id: from-move
    title: from.move()
    $ref: '@supabase/storage-js.packages/StorageFileApi.default.move'
    notes: |
      - RLS policy permissions required:
        - `buckets` table permissions: none
        - `objects` table permissions: `update` and `select`
      - Refer to the [Storage guide](/docs/guides/storage#access-control) on how access control works
    examples:
      - id: move-file
        name: Move file
        isSpotlight: true
        code: |
          ```kotlin
          val bucket = client.storage["avatars"]
          bucket.move("icon1.png", "icon2.png")
          ```

  - id: from-create-signed-url
    title: from.createSignedUrl()
    $ref: '@supabase/storage-js.packages/StorageFileApi.default.createSignedUrl'
    notes: |
      - RLS policy permissions required:
        - `buckets` table permissions: none
        - `objects` table permissions: `select`
      - Refer to the [Storage guide](/docs/guides/storage#access-control) on how access control works
    examples:
      - id: create-signed-url
        name: Create Signed URL
        isSpotlight: true
        code: |
          ```kotlin
          val bucket = client.storage["avatars"]
          val url = bucket.createSignedUrl(path = "icon.png", expiresIn = 3.minutes)
          ```
      - id: create-signed-url-with-transformation
        name: Create Signed URL with transformation
        code: |
          ```kotlin
          val bucket = client.storage["avatars"]
          val url = bucket.createSignedUrl(path = "icon.png", expiresIn = 3.minutes) {
              size(100, 100)
              fill()
              quality = 80
          }    
          ```
  - id: from-download
    title: from.download()
    $ref: '@supabase/storage-js.packages/StorageFileApi.default.download'
    notes: |
      - RLS policy permissions required:
        - `buckets` table permissions: none
        - `objects` table permissions: `select`
      - Refer to the [Storage guide](/docs/guides/storage#access-control) on how access control works
    examples:
      - id: download-file-authenticated
        name: Download file from non-public bucket
        isSpotlight: true
        code: |
          ```kotlin
          val bucket = client.storage["avatars"]
          val bytes = bucket.downloadAuthenticated("test.png")
          //or on JVM:
          bucket.downloadAuthenticatedTo("test.png", File("test.png"))
          ```
      - id: download-file-public
        name: Download file from public bucket
        isSpotlight: true
        code: |
          ```kotlin
          val bucket = client.storage["avatars"]
          val bytes = bucket.downloadPublic("test.png")
          //or on JVM:
          bucket.downloadPublicTo("test.png", File("test.png"))
          ```    
      - id: download-with-transformation
        name: Download file with transformation
        code: |
          ```kotlin
          val bucket = client.storage["avatars"]
          val bytes = bucket.downloadPublic("test.png") {
              size(100, 100)
              fill()
              quality = 100
          }
          ```  
      - id: download-with-progress
        name: Download file with progress 
        code: |
          ```kotlin
          val bucket = client.storage["avatars"]
          bucket.downloadAuthenticatedAsFlow("icon.png").collect {
              when(it) {
                  is DownloadStatus.ByteData -> println("Downloaded ${it.data.size} bytes")
                  is DownloadStatus.Progress -> println("Downloaded ${it.totalBytesReceived.toFloat() / it.contentLength * 100}%")
                  DownloadStatus.Success -> println("Downloaded successfully")
              }
          }
          ```       
  - id: from-remove
    title: from.remove()
    $ref: '@supabase/storage-js.packages/StorageFileApi.default.remove'
    notes: |
      - RLS policy permissions required:
        - `buckets` table permissions: none
        - `objects` table permissions: `delete` and `select`
      - Refer to the [Storage guide](/docs/guides/storage#access-control) on how access control works
    examples:
      - id: delete-file
        name: Delete file
        isSpotlight: true
        code: |
          ```kotlin
          val bucket = client.storage["avatars"]
          bucket.delete("test.png", "test2.png")
          ```

  - id: from-list
    title: from.list()
    $ref: '@supabase/storage-js.packages/StorageFileApi.default.list'
    notes: |
      - RLS policy permissions required:
        - `buckets` table permissions: none
        - `objects` table permissions: `select`
      - Refer to the [Storage guide](/docs/guides/storage#access-control) on how access control works
    examples:
      - id: list-files-in-a-bucket
        name: List files in a bucket
        isSpotlight: true
        code: |
          ```kotlin
          val bucket = client.storage["avatars"]
          val files = bucket.list()
          ```
