{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "assistant",
  "type": "registry:block",
  "title": "AI Assistant with Database Query",
  "description": "AI chatbot widget with database query capabilities through MCP (Model Context Protocol)",
  "dependencies": [
    "ai@latest",
    "@ai-sdk/react@latest",
    "@ai-sdk/openai@latest",
    "@ai-sdk/mcp@latest",
    "@supabase/ssr@latest",
    "@supabase/supabase-js@latest",
    "zod@latest",
    "nanoid@latest",
    "sonner@latest",
    "lucide-react@latest"
  ],
  "registryDependencies": [
    "button",
    "input",
    "scroll-area",
    "@ai-elements/conversation",
    "@ai-elements/message",
    "@ai-elements/prompt-input",
    "@ai-elements/model-selector",
    "@ai-elements/reasoning",
    "@ai-elements/sources",
    "@ai-elements/suggestion"
  ],
  "files": [
    {
      "path": "registry/default/blocks/assistant/components/assistant-widget.tsx",
      "content": "'use client'\n\nimport { cn } from '@/lib/utils'\nimport {\n  Conversation,\n  ConversationContent,\n  ConversationScrollButton,\n} from '@/registry/default/components/ai-elements/conversation'\nimport {\n  Message,\n  MessageBranch,\n  MessageBranchContent,\n  MessageContent,\n  MessageResponse,\n} from '@/registry/default/components/ai-elements/message'\nimport {\n  ModelSelector,\n  ModelSelectorContent,\n  ModelSelectorEmpty,\n  ModelSelectorGroup,\n  ModelSelectorInput,\n  ModelSelectorItem,\n  ModelSelectorList,\n  ModelSelectorLogo,\n  ModelSelectorLogoGroup,\n  ModelSelectorName,\n  ModelSelectorTrigger,\n} from '@/registry/default/components/ai-elements/model-selector'\nimport {\n  PromptInput,\n  PromptInputActionAddAttachments,\n  PromptInputActionMenu,\n  PromptInputActionMenuContent,\n  PromptInputActionMenuTrigger,\n  PromptInputAttachment,\n  PromptInputAttachments,\n  PromptInputBody,\n  PromptInputButton,\n  PromptInputFooter,\n  PromptInputHeader,\n  type PromptInputMessage,\n  PromptInputSubmit,\n  PromptInputTextarea,\n  PromptInputTools,\n} from '@/registry/default/components/ai-elements/prompt-input'\nimport {\n  Reasoning,\n  ReasoningContent,\n  ReasoningTrigger,\n} from '@/registry/default/components/ai-elements/reasoning'\nimport {\n  Source,\n  Sources,\n  SourcesContent,\n  SourcesTrigger,\n} from '@/registry/default/components/ai-elements/sources'\nimport { Suggestion, Suggestions } from '@/registry/default/components/ai-elements/suggestion'\nimport { Button } from '@/registry/default/components/ui/button'\nimport { useChat } from '@ai-sdk/react'\nimport type { Message as ChatMessage } from 'ai'\nimport { CheckIcon, GlobeIcon, Loader2, MessageSquare, MicIcon, Minimize2, X } from 'lucide-react'\nimport { useCallback, useEffect, useMemo, useState } from 'react'\nimport { toast } from 'sonner'\nimport { createClient } from '@/registry/default/blocks/assistant/lib/supabase/client'\n\nconst suggestions = [\n  'Show me my recent orders',\n  'How many active users do we have?',\n  'List all tasks due this week',\n  \"Summarize today's signups\",\n]\n\nconst models = [\n  {\n    id: 'gpt-4o',\n    name: 'GPT-4o',\n    chef: 'OpenAI',\n    chefSlug: 'openai',\n    providers: ['openai', 'azure'],\n  },\n  {\n    id: 'gpt-4o-mini',\n    name: 'GPT-4o Mini',\n    chef: 'OpenAI',\n    chefSlug: 'openai',\n    providers: ['openai', 'azure'],\n  },\n  {\n    id: 'claude-sonnet-4-20250514',\n    name: 'Claude 4 Sonnet',\n    chef: 'Anthropic',\n    chefSlug: 'anthropic',\n    providers: ['anthropic', 'azure', 'google', 'amazon-bedrock'],\n  },\n]\n\ntype ComposerStatus = 'ready' | 'submitted' | 'streaming' | 'error'\n\ntype MessageMetadata = {\n  sources?: { href: string; title: string }[]\n  reasoning?: {\n    content: string\n    duration: number\n  }\n}\n\ntype ToolInvocationItem = NonNullable<ChatMessage['toolInvocations']>[number]\n\nconst getMessageText = (content: ChatMessage['content']) => {\n  if (typeof content === 'string') {\n    return content\n  }\n\n  return content\n    .map((part) => (part.type === 'text' ? part.text : ''))\n    .join('')\n    .trim()\n}\n\nconst SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL?.replace(/\\/$/, '')\nconst DEFAULT_CHAT_API = SUPABASE_URL ? `${SUPABASE_URL}/functions/v1/chat` : '/functions/v1/chat'\nconst CHAT_API_URL = process.env.NEXT_PUBLIC_ASSISTANT_CHAT_URL ?? DEFAULT_CHAT_API\n\nexport function AssistantWidget() {\n  const supabase = useMemo(() => createClient(), [])\n  const fetchWithAuth = useCallback(\n    async (\n      input: Parameters<typeof fetch>[0],\n      init?: Parameters<typeof fetch>[1]\n    ): Promise<Response> => {\n      const {\n        data: { session },\n        error: sessionError,\n      } = await supabase.auth.getSession()\n\n      if (sessionError || !session) {\n        throw new Error('You must be signed in to chat with the assistant.')\n      }\n\n      const headers = new Headers(init?.headers ?? {})\n      headers.set('Authorization', `Bearer ${session.access_token}`)\n\n      return fetch(input, {\n        ...init,\n        headers,\n      })\n    },\n    [supabase]\n  )\n  const [isOpen, setIsOpen] = useState(false)\n  const [isMinimized, setIsMinimized] = useState(false)\n  const [text, setText] = useState('')\n  const [status, setStatus] = useState<ComposerStatus>('ready')\n  const [model, setModel] = useState(models[0].id)\n  const [modelSelectorOpen, setModelSelectorOpen] = useState(false)\n  const [useWebSearch, setUseWebSearch] = useState(false)\n  const [useMicrophone, setUseMicrophone] = useState(false)\n\n  const { messages, append, isLoading, error } = useChat({\n    api: CHAT_API_URL,\n    fetch: fetchWithAuth,\n    onError: (chatError) => {\n      toast.error('Failed to send message', {\n        description: chatError.message,\n      })\n      setStatus('error')\n    },\n  })\n\n  useEffect(() => {\n    if (isLoading) {\n      setStatus('streaming')\n      return\n    }\n\n    if (!isLoading && status === 'streaming') {\n      setStatus('ready')\n    }\n  }, [isLoading, status])\n\n  useEffect(() => {\n    if (!error && status === 'error') {\n      setStatus('ready')\n    }\n  }, [error, status])\n\n  const selectedModel = useMemo(() => models.find((entry) => entry.id === model), [model])\n\n  const handleSubmit = async (message: PromptInputMessage) => {\n    const hasText = Boolean(message.text?.trim())\n    const hasAttachments = Boolean(message.files?.length)\n\n    if (!(hasText || hasAttachments) || isLoading) {\n      return\n    }\n\n    setStatus('submitted')\n\n    if (message.files?.length) {\n      toast.success('Files attached', {\n        description: `${message.files.length} file(s) attached to message`,\n      })\n    }\n\n    try {\n      await append({\n        role: 'user',\n        content: message.text?.trim() ?? 'Sent with attachments',\n        metadata: {\n          model,\n          useWebSearch,\n          useMicrophone,\n        },\n      })\n    } catch (submissionError) {\n      console.error(submissionError)\n      setStatus('error')\n      return\n    }\n\n    setText('')\n  }\n\n  const handleSuggestionClick = async (suggestion: string) => {\n    if (isLoading) return\n    setStatus('submitted')\n    try {\n      await append({ role: 'user', content: suggestion })\n    } catch (suggestionError) {\n      console.error(suggestionError)\n      setStatus('error')\n    }\n  }\n\n  const renderToolInvocation = (tool: ToolInvocationItem) => {\n    if (!tool) return null\n\n    return (\n      <div key={tool.toolCallId} className=\"mt-3 rounded-md border bg-background/60 p-2 text-xs\">\n        <div className=\"font-semibold\">{tool.toolName}</div>\n        {tool.state === 'call' && (\n          <div className=\"flex items-center gap-2 text-muted-foreground\">\n            <Loader2 className=\"h-3 w-3 animate-spin\" />\n            Runningâ€¦\n          </div>\n        )}\n        {tool.state === 'result' && (\n          <div className=\"text-muted-foreground\">\n            {typeof tool.result === 'string' ? tool.result : JSON.stringify(tool.result, null, 2)}\n          </div>\n        )}\n        {tool.state === 'error' && <div className=\"text-destructive\">{tool.error}</div>}\n      </div>\n    )\n  }\n\n  if (!isOpen) {\n    return (\n      <button\n        onClick={() => setIsOpen(true)}\n        className=\"fixed bottom-6 right-6 z-50 flex h-14 w-14 items-center justify-center rounded-full bg-primary text-primary-foreground shadow-lg transition-all hover:bg-primary/90\"\n        aria-label=\"Open AI Assistant\"\n      >\n        <MessageSquare className=\"h-6 w-6\" />\n      </button>\n    )\n  }\n\n  return (\n    <div\n      className={cn(\n        'fixed bottom-6 right-6 z-50 flex flex-col rounded-lg border bg-background shadow-2xl transition-all',\n        isMinimized ? 'h-14 w-80' : 'h-[640px] w-[420px]'\n      )}\n    >\n      <div className=\"flex items-center justify-between border-b bg-muted/60 px-4 py-3\">\n        <div className=\"flex items-center gap-2\">\n          <MessageSquare className=\"h-5 w-5\" />\n          <div>\n            <p className=\"text-sm font-semibold\">AI Assistant</p>\n            <p className=\"text-xs text-muted-foreground\">Powered by MCP</p>\n          </div>\n        </div>\n        <div className=\"flex items-center gap-1\">\n          <Button\n            variant=\"ghost\"\n            size=\"icon\"\n            className=\"h-8 w-8\"\n            onClick={() => setIsMinimized((prev) => !prev)}\n          >\n            <Minimize2 className=\"h-4 w-4\" />\n          </Button>\n          <Button variant=\"ghost\" size=\"icon\" className=\"h-8 w-8\" onClick={() => setIsOpen(false)}>\n            <X className=\"h-4 w-4\" />\n          </Button>\n        </div>\n      </div>\n\n      {!isMinimized && (\n        <>\n          <div className=\"flex-1 overflow-hidden\">\n            <Conversation className=\"flex h-full flex-col\">\n              <ConversationContent>\n                {messages.length === 0 && (\n                  <div className=\"flex h-full flex-col items-center justify-center gap-2 text-center text-sm text-muted-foreground\">\n                    <p>Hi! I'm your AI assistant.</p>\n                    <p>I can help you query your data using natural language.</p>\n                  </div>\n                )}\n                {messages.map((message) => {\n                  const content = getMessageText(message.content)\n                  const hasTools = Boolean(message.toolInvocations?.length)\n                  const metadata = message.metadata as MessageMetadata | undefined\n\n                  return (\n                    <MessageBranch defaultBranch={0} key={message.id}>\n                      <MessageBranchContent>\n                        <Message from={message.role === 'user' ? 'user' : 'assistant'}>\n                          <div>\n                            {metadata?.sources?.length ? (\n                              <Sources>\n                                <SourcesTrigger count={metadata.sources.length} />\n                                <SourcesContent>\n                                  {metadata.sources.map(\n                                    (source: { href: string; title: string }) => (\n                                      <Source\n                                        key={source.href}\n                                        href={source.href}\n                                        title={source.title}\n                                      />\n                                    )\n                                  )}\n                                </SourcesContent>\n                              </Sources>\n                            ) : null}\n\n                            {metadata?.reasoning && (\n                              <Reasoning duration={metadata.reasoning.duration}>\n                                <ReasoningTrigger />\n                                <ReasoningContent>{metadata.reasoning.content}</ReasoningContent>\n                              </Reasoning>\n                            )}\n\n                            <MessageContent>\n                              <MessageResponse>{content}</MessageResponse>\n                            </MessageContent>\n\n                            {hasTools && (\n                              <div className=\"mt-2 space-y-2\">\n                                {message.toolInvocations?.map((tool) => renderToolInvocation(tool))}\n                              </div>\n                            )}\n                          </div>\n                        </Message>\n                      </MessageBranchContent>\n                    </MessageBranch>\n                  )\n                })}\n                {isLoading && (\n                  <div className=\"flex justify-start\">\n                    <Loader2 className=\"h-4 w-4 animate-spin text-muted-foreground\" />\n                  </div>\n                )}\n              </ConversationContent>\n              <ConversationScrollButton />\n            </Conversation>\n          </div>\n\n          <div className=\"grid shrink-0 gap-3 border-t bg-background/95 pt-3\">\n            <Suggestions className=\"px-4\">\n              {suggestions.map((suggestion) => (\n                <Suggestion\n                  key={suggestion}\n                  suggestion={suggestion}\n                  onClick={() => handleSuggestionClick(suggestion)}\n                />\n              ))}\n            </Suggestions>\n            <div className=\"px-4 pb-4\">\n              <PromptInput globalDrop multiple onSubmit={handleSubmit}>\n                <PromptInputHeader>\n                  <PromptInputAttachments>\n                    {(attachment) => <PromptInputAttachment data={attachment} />}\n                  </PromptInputAttachments>\n                </PromptInputHeader>\n                <PromptInputBody>\n                  <PromptInputTextarea\n                    value={text}\n                    onChange={(event) => setText(event.target.value)}\n                    placeholder=\"Ask me anything about your Supabase data...\"\n                  />\n                </PromptInputBody>\n                <PromptInputFooter>\n                  <PromptInputTools>\n                    <PromptInputActionMenu>\n                      <PromptInputActionMenuTrigger />\n                      <PromptInputActionMenuContent>\n                        <PromptInputActionAddAttachments />\n                      </PromptInputActionMenuContent>\n                    </PromptInputActionMenu>\n                    <PromptInputButton\n                      onClick={() => setUseMicrophone((prev) => !prev)}\n                      variant={useMicrophone ? 'default' : 'ghost'}\n                      type=\"button\"\n                    >\n                      <MicIcon size={16} />\n                      <span className=\"sr-only\">Toggle microphone</span>\n                    </PromptInputButton>\n                    <PromptInputButton\n                      onClick={() => setUseWebSearch((prev) => !prev)}\n                      variant={useWebSearch ? 'default' : 'ghost'}\n                      type=\"button\"\n                    >\n                      <GlobeIcon size={16} />\n                      <span className=\"sr-only\">Toggle web search</span>\n                    </PromptInputButton>\n                    <ModelSelector open={modelSelectorOpen} onOpenChange={setModelSelectorOpen}>\n                      <ModelSelectorTrigger asChild>\n                        <PromptInputButton type=\"button\">\n                          {selectedModel?.chefSlug && (\n                            <ModelSelectorLogo provider={selectedModel.chefSlug} />\n                          )}\n                          {selectedModel?.name && (\n                            <ModelSelectorName>{selectedModel.name}</ModelSelectorName>\n                          )}\n                        </PromptInputButton>\n                      </ModelSelectorTrigger>\n                      <ModelSelectorContent>\n                        <ModelSelectorInput placeholder=\"Search models...\" />\n                        <ModelSelectorList>\n                          <ModelSelectorEmpty>No models found.</ModelSelectorEmpty>\n                          {['OpenAI', 'Anthropic'].map((chef) => (\n                            <ModelSelectorGroup key={chef} heading={chef}>\n                              {models\n                                .filter((entry) => entry.chef === chef)\n                                .map((entry) => (\n                                  <ModelSelectorItem\n                                    key={entry.id}\n                                    value={entry.id}\n                                    onSelect={() => {\n                                      setModel(entry.id)\n                                      setModelSelectorOpen(false)\n                                    }}\n                                  >\n                                    <ModelSelectorLogo provider={entry.chefSlug} />\n                                    <ModelSelectorName>{entry.name}</ModelSelectorName>\n                                    <ModelSelectorLogoGroup>\n                                      {entry.providers.map((provider) => (\n                                        <ModelSelectorLogo key={provider} provider={provider} />\n                                      ))}\n                                    </ModelSelectorLogoGroup>\n                                    {model === entry.id ? (\n                                      <CheckIcon className=\"ml-auto h-4 w-4\" />\n                                    ) : (\n                                      <div className=\"ml-auto h-4 w-4\" />\n                                    )}\n                                  </ModelSelectorItem>\n                                ))}\n                            </ModelSelectorGroup>\n                          ))}\n                        </ModelSelectorList>\n                      </ModelSelectorContent>\n                    </ModelSelector>\n                  </PromptInputTools>\n                  <PromptInputSubmit status={status} disabled={!text.trim() || isLoading} />\n                </PromptInputFooter>\n              </PromptInput>\n              {error && <p className=\"mt-2 text-xs text-destructive\">{error.message}</p>}\n            </div>\n          </div>\n        </>\n      )}\n    </div>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/default/blocks/assistant/lib/supabase/server.ts",
      "content": "import { createServerClient } from '@supabase/ssr'\nimport { cookies } from 'next/headers'\n\n/**\n * If using Fluid compute: Don't put this client in a global variable. Always create a new client within each\n * function when using it.\n */\nexport async function createClient() {\n  const cookieStore = await cookies()\n\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll()\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) =>\n              cookieStore.set(name, value, options)\n            )\n          } catch {\n            // The `setAll` method was called from a Server Component.\n            // This can be ignored if you have middleware refreshing\n            // user sessions.\n          }\n        },\n      },\n    }\n  )\n}\n",
      "type": "registry:file",
      "target": "lib/supabase/server.ts"
    },
    {
      "path": "registry/default/blocks/assistant/lib/supabase/client.ts",
      "content": "import { createBrowserClient } from '@supabase/ssr'\n\nexport function createClient() {\n  return createBrowserClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n  )\n}\n",
      "type": "registry:file",
      "target": "lib/supabase/client.ts"
    },
    {
      "path": "registry/default/blocks/assistant/lib/supabase/middleware.ts",
      "content": "import { createServerClient } from '@supabase/ssr'\nimport { NextResponse, type NextRequest } from 'next/server'\n\nexport async function updateSession(request: NextRequest) {\n  let supabaseResponse = NextResponse.next({\n    request,\n  })\n\n  const supabase = createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return request.cookies.getAll()\n        },\n        setAll(cookiesToSet) {\n          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value))\n          supabaseResponse = NextResponse.next({\n            request,\n          })\n          cookiesToSet.forEach(({ name, value, options }) =>\n            supabaseResponse.cookies.set(name, value, options)\n          )\n        },\n      },\n    }\n  )\n\n  // IMPORTANT: Avoid writing any logic between createServerClient and\n  // supabase.auth.getUser(). A simple mistake could make it very hard to debug\n  // issues with users being randomly logged out.\n\n  const {\n    data: { user },\n  } = await supabase.auth.getUser()\n\n  // IMPORTANT: You *must* return the supabaseResponse object as it is.\n  // If you're creating a new response object with NextResponse.next() make sure to:\n  // 1. Pass the request in it, like so:\n  //    const myNewResponse = NextResponse.next({ request })\n  // 2. Copy over the cookies, like so:\n  //    myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll())\n  // 3. Change the myNewResponse object to fit your needs, but avoid changing\n  //    the cookies!\n  // 4. Finally:\n  //    return myNewResponse\n  // If this is not done, you may be causing the browser and server to go out\n  // of sync and terminate the user's session prematurely.\n\n  return supabaseResponse\n}\n",
      "type": "registry:file",
      "target": "lib/supabase/middleware.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/mcp-server/index.ts",
      "content": "// Follow this setup guide to integrate the Deno language server with your editor:\n// https://deno.land/manual/getting_started/setup_your_environment\n// This enables autocomplete, go to definition, etc.\n//\n// Setup type definitions for built-in Supabase Runtime APIs\n/// <reference types=\"https://esm.sh/@supabase/functions-js/src/edge-runtime.d.ts\" />\n\nimport { Hono } from \"hono\";\nimport { McpServer, StreamableHttpTransport } from \"mcp-lite\";\nimport { z } from \"zod\";\n\n// We create two Hono instances:\n// 1. `app` is the root handler for the Supabase Edge Function (must match the function name, e.g. /mcp-server)\n// 2. `mcpApp` handles the MCP protocol and health endpoints, mounted under the function route\n// This pattern is required because Supabase Edge Functions route all requests to /<function-name>/*\n\nconst mcp = new McpServer({\n  name: \"supabase-assistant-mcp-server\",\n  version: \"1.0.0\",\n  schemaAdapter: (schema: unknown) => z.toJSONSchema(schema as z.ZodType),\n});\n\n// Temporary placeholder tool while wiring up the rest of the MCP server.\nmcp.tool(\"queryDatabase\", {\n  description:\n    \"Example placeholder tool that just echoes a string back to the caller.\",\n  inputSchema: z.object({\n    message: z\n      .string()\n      .default(\"Hello from the Supabase MCP server!\")\n      .describe(\"Optional message you would like the tool to return\"),\n  }),\n  handler: async ({ message }: { message: string }) => {\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: `Example tool response: ${message}`,\n        },\n      ],\n    };\n  },\n});\n\nconst transport = new StreamableHttpTransport();\nconst httpHandler = transport.bind(mcp);\n\nconst app = new Hono();\nconst mcpApp = new Hono();\n\nmcpApp.get(\"/\", (c) => {\n  return c.json({\n    message: \"MCP Server on Supabase Edge Functions\",\n    endpoints: {\n      mcp: \"/mcp\",\n      health: \"/health\",\n    },\n  });\n});\n\nmcpApp.get(\"/health\", (c) => {\n  return c.json({\n    message: \"Service is up and running\",\n  });\n});\n\nmcpApp.all(\"/mcp\", async (c) => {\n  const response = await httpHandler(c.req.raw);\n  return response;\n});\n\n// Mount the MCP app at /mcp-server (matches the function name)\napp.route(\"/mcp-server\", mcpApp);\n\nexport default app;\n\n/* To invoke locally:\n\n  1. Run `supabase start` (see: https://supabase.com/docs/reference/cli/supabase-start)\n  2. Make an HTTP request:\n\n  curl -i --location --request POST 'http://127.0.0.1:54321/functions/v1/mcp-server/mcp' \\\n    --header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZS1kZW1vIiwicm9sZSI6ImFub24iLCJleHAiOjE5ODM4MTI5OTZ9.CRXP1A7WOeoJeXxjNni43kdQwgnWNReilDMblYTn_I0' \\\n    --header 'Content-Type: application/json' \\\n    --data '{\"jsonrpc\":\"2.0\",\"method\":\"tools/list\",\"id\":1}'\n\n  3. Test the health endpoint:\n\n  curl 'http://127.0.0.1:54321/functions/v1/mcp-server/health'\n\n*/\n",
      "type": "registry:file",
      "target": "supabase/functions/mcp-server/index.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/mcp-server/deno.json",
      "content": "{\n  \"compilerOptions\": {\n    \"lib\": [\"deno.window\", \"deno.ns\"],\n    \"strict\": true\n  },\n  \"imports\": {\n    \"hono\": \"npm:hono@^4.6.14\",\n    \"mcp-lite\": \"npm:mcp-lite@0.8.2\",\n    \"zod\": \"npm:zod@^4.1.12\",\n    \"@supabase/supabase-js\": \"npm:@supabase/supabase-js@^2\"\n  }\n}\n",
      "type": "registry:file",
      "target": "supabase/functions/mcp-server/deno.json"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/chat/index.ts",
      "content": "import { experimental_createMCPClient as createMCPClient } from '@ai-sdk/mcp'\nimport { openai } from '@ai-sdk/openai'\nimport { streamText, type CoreMessage } from 'ai'\nimport { z } from 'zod'\n\ntype ChatRequestBody = {\n  messages?: CoreMessage[]\n  model?: string\n}\n\nconst queryDatabaseInputSchema = z.object({\n  table: z.string().describe('The name of the table to query'),\n  columns: z\n    .string()\n    .optional()\n    .describe(\"Columns to select (comma-separated). Defaults to '*' for all columns.\"),\n  filters: z\n    .array(\n      z.object({\n        column: z.string().describe('The column to filter on'),\n        operator: z\n          .enum(['eq', 'neq', 'gt', 'gte', 'lt', 'lte', 'like', 'ilike', 'in', 'is'])\n          .describe('The filter operator'),\n        value: z.any().describe('The value to filter by'),\n      })\n    )\n    .optional()\n    .describe('Array of filter conditions to apply'),\n  limit: z.number().optional().describe('Maximum number of rows to return'),\n  orderBy: z\n    .object({\n      column: z.string().describe('Column to order by'),\n      ascending: z.boolean().optional().describe('Sort order (default: true)'),\n    })\n    .optional()\n    .describe('Ordering options'),\n  explanation: z.string().optional().describe('Optional explanation of what the query does'),\n})\n\nconst supabaseUrl = Deno.env.get('SUPABASE_URL')?.replace(/\\/$/, '')\nconst defaultMcpServerUrl = supabaseUrl ? `${supabaseUrl}/functions/v1/mcp-server` : undefined\n\nconst mcpServerUrl =\n  Deno.env.get('MCP_SERVER_URL') ??\n  Deno.env.get('NEXT_PUBLIC_MCP_SERVER_URL') ??\n  defaultMcpServerUrl ??\n  'http://localhost:54321/functions/v1/mcp-server'\n\nconst corsHeaders: Record<string, string> = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Headers': 'authorization, content-type',\n  'Access-Control-Allow-Methods': 'POST, OPTIONS',\n}\n\nconst systemPrompt = `You are a helpful AI assistant with access to a database.\nYou can help users query their database using natural language.\nUse the queryDatabase tool to fetch data from tables with filters and options.\nAlways provide clear explanations of what the query does.\nThe database respects Row Level Security (RLS), so users can only access their own data.\nWhen building queries:\n- Use the table parameter to specify which table to query\n- Use filters array to add conditions (eq, neq, gt, gte, lt, lte, like, ilike, in, is)\n- Use limit to control the number of results\n- Use orderBy to sort results by a specific column`\n\nDeno.serve(async (req) => {\n  if (req.method === 'OPTIONS') {\n    return new Response('ok', { headers: corsHeaders })\n  }\n\n  if (req.method !== 'POST') {\n    return new Response('Method Not Allowed', {\n      status: 405,\n      headers: corsHeaders,\n    })\n  }\n\n  const authHeader = req.headers.get('Authorization')\n  if (!authHeader) {\n    return new Response(JSON.stringify({ error: 'Unauthorized' }), {\n      status: 401,\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n    })\n  }\n\n  let body: ChatRequestBody\n  try {\n    body = await req.json()\n  } catch {\n    return new Response(JSON.stringify({ error: 'Invalid JSON payload' }), {\n      status: 400,\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n    })\n  }\n\n  if (!body.messages || !Array.isArray(body.messages)) {\n    return new Response(JSON.stringify({ error: 'Request must include a messages array' }), {\n      status: 400,\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n    })\n  }\n\n  const modelId = body.model && typeof body.model === 'string' ? body.model : 'gpt-4o'\n\n  let mcpClient: Awaited<ReturnType<typeof createMCPClient>> | null = null\n  let clientClosed = false\n\n  const closeMcpClient = async () => {\n    if (!mcpClient || clientClosed) return\n    clientClosed = true\n    try {\n      await mcpClient.close()\n    } catch (closeError) {\n      console.error('Failed to close MCP client:', closeError)\n    }\n  }\n\n  try {\n    mcpClient = await createMCPClient({\n      transport: {\n        type: 'http',\n        url: mcpServerUrl,\n        headers: {\n          Authorization: authHeader,\n        },\n      },\n    })\n\n    const tools = await mcpClient.tools({\n      schemas: {\n        queryDatabase: {\n          inputSchema: queryDatabaseInputSchema,\n        },\n      },\n    })\n\n    const result = await streamText({\n      model: openai(modelId),\n      messages: body.messages,\n      tools,\n      system: systemPrompt,\n      onFinish: closeMcpClient,\n    })\n\n    return result.toTextStreamResponse({ headers: corsHeaders })\n  } catch (error) {\n    await closeMcpClient()\n    console.error('Assistant chat error:', error)\n    return new Response(\n      JSON.stringify({\n        error: 'Failed to process chat request',\n        details: error instanceof Error ? error.message : String(error),\n      }),\n      {\n        status: 500,\n        headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n      }\n    )\n  }\n})\n",
      "type": "registry:file",
      "target": "supabase/functions/chat/index.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/chat/deno.json",
      "content": "{\n  \"compilerOptions\": {\n    \"lib\": [\"deno.window\", \"deno.ns\"],\n    \"strict\": true\n  },\n  \"imports\": {\n    \"hono\": \"npm:hono@^4.6.14\",\n    \"zod\": \"npm:zod@^4.1.12\",\n    \"ai\": \"npm:ai@^5.0.90\",\n    \"@ai-sdk/openai\": \"npm:@ai-sdk/openai@^2.0.32\",\n    \"@ai-sdk/mcp\": \"npm:@ai-sdk/mcp@latest\"\n  }\n}\n",
      "type": "registry:file",
      "target": "supabase/functions/chat/deno.json"
    },
    {
      "path": "registry/default/blocks/assistant/README.md",
      "content": "# AI Assistant Block\n\nAn AI-powered chatbot widget with database query capabilities using the Model Context Protocol (MCP).\n\n## Features\n\n- Fixed bottom-right chat widget with minimize/expand controls\n- Natural language database queries using AI\n- Row Level Security (RLS) enforcement\n- Streaming responses with real-time feedback\n- Tool execution visualization\n- Secure SQL query execution with validation\n- Rich AI SDK Elements (Conversation, Messages, Prompt Input, Model Selector, Suggestions, Sources, Reasoning) for a modern assistant UX\n\n## Architecture\n\nThe block consists of four main pieces that work together end to end:\n\n1. **Assistant Widget** (`components/assistant-widget.tsx`): React component providing the chat UI, built with AI SDK Elements\n2. **Chat Edge Function** (`supabase/functions/chat/`): Supabase Edge Function that streams chat completions, bootstraps the MCP client, and is invoked directly from the browser\n3. **Hono MCP Server** (`supabase/functions/mcp-server/`): Supabase Edge Function exposing MCP tools (e.g. `queryDatabase`) via the `mcp-lite` transport\n4. **Supabase Client Utilities** (`lib/supabase/`): Server and browser helpers for authenticated Supabase access\n\n## Prerequisites\n\n- Supabase project with authentication enabled\n- OpenAI API key (or another MCP-compatible LLM provider)\n- Supabase CLI installed\n- Docker (for Supabase local dev)\n- Node.js and npm/pnpm installed\n- Deno 2.x (Supabase Edge Functions runtime)\n\n## Setup Instructions\n\n### 1. Install the Block\n\n```bash\nnpx shadcn@latest add https://ui.supabase.com/r/assistant\n```\n\n### 2. Install UI + AI SDK Elements\n\nThe assistant widget depends on both core UI primitives and the AI SDK Element registry entries. Install them (or make sure they already exist in your project) using the shadcn CLI:\n\n```bash\nnpx shadcn@latest add button input scroll-area \\\n  @ai-elements/conversation \\\n  @ai-elements/message \\\n  @ai-elements/prompt-input \\\n  @ai-elements/model-selector \\\n  @ai-elements/reasoning \\\n  @ai-elements/sources \\\n  @ai-elements/suggestion\n```\n\nEach AI Element ships ready-to-style JSX + Tailwind so you can compose advanced assistant surfaces without rebuilding primitives.\n\n### 3. Set Up Environment Variables\n\nAdd the following to your `.env.local`:\n\n```env\n# OpenAI API Key\nOPENAI_API_KEY=your_openai_api_key\n\n# Supabase Configuration\nNEXT_PUBLIC_SUPABASE_URL=your_supabase_url\nNEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key\n\n# Chat Edge Function (used by the browser)\nNEXT_PUBLIC_ASSISTANT_CHAT_URL=https://your-project.supabase.co/functions/v1/chat\n\n# MCP Server URL (consumed by the edge functions)\nMCP_SERVER_URL=https://your-project.supabase.co/functions/v1/mcp-server\n```\n\n### 4. Build and Deploy the Hono MCP Server\n\nSupabase Edge Functions route every request to `/<function-name>/*`, so the MCP server needs the \"two Hono apps\" pattern outlined in the [Supabase mcp-lite guide](https://supabase.com/docs/guides/functions/examples/mcp-server-mcp-lite):\n\n1. **Scaffold (optional):** `npm create mcp-lite@latest` and choose the **Supabase Edge Functions (MCP server)** template to bootstrap `supabase/functions/mcp-server`.\n2. **Import map:** Ensure `supabase/functions/mcp-server/deno.json` includes the dependencies the block uses:\n\n```jsonc\n{\n  \"compilerOptions\": {\n    \"lib\": [\"deno.window\", \"deno.ns\"],\n    \"strict\": true\n  },\n  \"imports\": {\n    \"hono\": \"npm:hono@^4.6.14\",\n    \"mcp-lite\": \"npm:mcp-lite@0.8.2\",\n    \"zod\": \"npm:zod@^4.1.12\",\n    \"@supabase/supabase-js\": \"npm:@supabase/supabase-js@^2.48.0\"\n  }\n}\n```\n\n3. **Hono entrypoint:** Update `supabase/functions/mcp-server/index.ts` to mount the MCP transport behind `/mcp-server/mcp`:\n\n```ts\nimport { Hono } from \"hono\";\nimport { McpServer, StreamableHttpTransport } from \"mcp-lite\";\nimport { createClient } from \"@supabase/supabase-js\";\nimport { z } from \"zod\";\n\nconst mcp = new McpServer({\n  name: \"supabase-assistant-mcp-server\",\n  version: \"1.0.0\",\n  schemaAdapter: (schema) => z.toJSONSchema(schema as z.ZodType),\n});\n\n// ...define queryDatabase and other tools that create an authenticated Supabase client\n\nconst transport = new StreamableHttpTransport();\nconst httpHandler = transport.bind(mcp);\n\nconst mcpApp = new Hono();\nmcpApp.get(\"/\", (c) =>\n  c.json({\n    message: \"MCP Server on Supabase Edge Functions\",\n    endpoints: { mcp: \"/mcp\", health: \"/health\" },\n  })\n);\nmcpApp.get(\"/health\", (c) => c.json({ status: \"ok\" }));\nmcpApp.all(\"/mcp\", (c) => httpHandler(c.req.raw));\n\nconst app = new Hono();\napp.route(\"/mcp-server\", mcpApp);\n\nDeno.serve((req) => app.fetch(req));\n```\n\nThis structure keeps Supabase's root handler (`/mcp-server`) separate from your MCP protocol endpoints while still serving the `StreamableHttpTransport`.\n\n4. **Serve locally:**\n\n```bash\nsupabase start\nsupabase functions serve --no-verify-jwt mcp-server\n```\n\nYour MCP endpoint will be available at `http://localhost:54321/functions/v1/mcp-server/mcp`.\n\n5. **Deploy globally:**\n\n```bash\nsupabase functions deploy --no-verify-jwt mcp-server\n```\n\n### 5. Build and Deploy the Chat Edge Function\n\nThe chat edge function (located at `supabase/functions/chat/`) replaces the `/api/chat` Next.js route and is what the browser calls directly.\n\n1. Confirm the provided `deno.json` contains the AI + MCP dependencies required by the block.\n2. Run `supabase start` if you haven't already.\n3. Serve **both** edge functions in separate terminals so the MCP server and chat handler run side by side:\n\n```bash\nsupabase functions serve --env-file .env.local --no-verify-jwt mcp-server\nsupabase functions serve --env-file .env.local --no-verify-jwt chat\n```\n\n4. For local development, set `NEXT_PUBLIC_ASSISTANT_CHAT_URL=http://127.0.0.1:54321/functions/v1/chat`. In production, point it to `https://<project>.supabase.co/functions/v1/chat`.\n5. Ensure `MCP_SERVER_URL` is available to the chat function (either via the Supabase dashboard or an `.env` file passed to `supabase functions serve`) so it can reach the MCP server endpoint.\n\n### 6. Add the Widget to Your App\n\n```tsx\nimport { AssistantWidget } from \"@/components/assistant-widget\";\n\nexport default function Layout({ children }) {\n  return (\n    <div>\n      {children}\n      <AssistantWidget />\n    </div>\n  );\n}\n```\n\n## Local Development & Testing\n\n- Start Supabase locally: `supabase start`\n- Serve and iterate on the MCP function: `supabase functions serve --no-verify-jwt mcp-server`\n- Run the chat edge function alongside it: `supabase functions serve --no-verify-jwt chat`\n- Test with Claude Code: `claude mcp add my-mcp-server -t http http://localhost:54321/functions/v1/mcp-server/mcp`\n- Inspect traffic using the MCP inspector: `npx @modelcontextprotocol/inspector`\n- When everything looks good, deploy via `supabase functions deploy --no-verify-jwt mcp-server`\n\n## Widget UI with AI SDK Elements\n\nThe block ships with AI SDK Element primitives (Conversation, Message, PromptInput, ModelSelector, etc.) located under `components/ai-elements`. Combine them to build an opinionated assistant surface, like the following demo:\n\n```tsx\n\"use client\";\n\nimport {\n  MessageBranch,\n  MessageBranchContent,\n  MessageBranchNext,\n  MessageBranchPage,\n  MessageBranchPrevious,\n  MessageBranchSelector,\n} from \"@/components/ai-elements/message\";\nimport {\n  Conversation,\n  ConversationContent,\n  ConversationScrollButton,\n} from \"@/components/ai-elements/conversation\";\nimport { Message, MessageContent } from \"@/components/ai-elements/message\";\nimport {\n  PromptInput,\n  PromptInputActionAddAttachments,\n  PromptInputActionMenu,\n  PromptInputActionMenuContent,\n  PromptInputActionMenuTrigger,\n  PromptInputAttachment,\n  PromptInputAttachments,\n  PromptInputBody,\n  PromptInputButton,\n  PromptInputFooter,\n  PromptInputHeader,\n  type PromptInputMessage,\n  PromptInputSubmit,\n  PromptInputTextarea,\n  PromptInputTools,\n} from \"@/components/ai-elements/prompt-input\";\nimport {\n  ModelSelector,\n  ModelSelectorContent,\n  ModelSelectorEmpty,\n  ModelSelectorGroup,\n  ModelSelectorInput,\n  ModelSelectorItem,\n  ModelSelectorList,\n  ModelSelectorLogo,\n  ModelSelectorLogoGroup,\n  ModelSelectorName,\n  ModelSelectorTrigger,\n} from \"@/components/ai-elements/model-selector\";\nimport {\n  Reasoning,\n  ReasoningContent,\n  ReasoningTrigger,\n} from \"@/components/ai-elements/reasoning\";\nimport { MessageResponse } from \"@/components/ai-elements/message\";\nimport {\n  Source,\n  Sources,\n  SourcesContent,\n  SourcesTrigger,\n} from \"@/components/ai-elements/sources\";\nimport { Suggestion, Suggestions } from \"@/components/ai-elements/suggestion\";\nimport type { ToolUIPart } from \"ai\";\nimport { CheckIcon, GlobeIcon, MicIcon } from \"lucide-react\";\nimport { nanoid } from \"nanoid\";\nimport { useCallback, useState } from \"react\";\nimport { toast } from \"sonner\";\n\n// ...rest of the Example component from the block's source (see components/assistant-widget.tsx)\n```\n\nThe complete example (available in this block) demonstrates:\n\n- Branching messages with sources, reasoning traces, and MCP tool output\n- Scrollable conversation history with streaming responses\n- Prompt composer with attachments, microphone toggle, and model selector\n- Reusable suggestions to quickly seed the assistant\n\nUse the snippet as a starting point for your own assistant surface or trim it down for a lighter footprint.\n\n## Usage\n\n### For End Users\n\n1. Click the chat icon in the bottom-right corner to open the assistant\n2. Type natural language queries about your data\n3. The AI will translate your questions into SQL and execute them via the `queryDatabase` MCP tool\n4. Results are displayed in the chat interface with tool execution feedback\n5. Minimize or close the widget as needed\n\n### Example Queries\n\n- \"Show me all my tasks\"\n- \"How many orders did I place last month?\"\n- \"List my recent transactions\"\n- \"What's the total revenue from my sales?\"\n\n## Security Considerations\n\n### Query Builder Approach\n\nThe MCP server uses Supabase's query builder for safe data access:\n\n- Uses the `queryDatabase` tool with structured parameters (table, filters, orderBy, limit)\n- No raw SQL injection risks\n- Queries execute with the authenticated user's context\n- All operations go through Supabase's security layer\n\n### Row Level Security (RLS)\n\nAll queries respect Supabase RLS policies:\n\n- The authenticated user's token is passed to the MCP server\n- Queries run with user context\n- Users can only access data allowed by RLS policies\n\n### Authentication\n\n- Local development uses `--no-verify-jwt` for speed; production deployments should enforce authentication per the [MCP authorization spec](https://modelcontextprotocol.io/spec)\n- Never expose production data without adding proper auth and auditing\n\n#### MCP middleware helpers\n\n`mcp-lite` ships with Hono-style middleware so you can enforce authentication, logging, and rate limiting *before* a tool executes. This keeps your auth logic centralized instead of duplicating it inside each tool handler:\n\n```ts\n// Logging\nmcp.use(async ({ req }, next) => {\n  const start = Date.now();\n  await next();\n  console.log(`${req.method} took ${Date.now() - start}ms`);\n});\n\n// Authentication\nmcp.use(async (ctx, next) => {\n  const token = ctx.req.header(\"Authorization\");\n  if (!token) throw new Error(\"Unauthorized\");\n\n  const user = await validateToken(token);\n  ctx.state.user = user;\n  await next();\n});\n\n// Rate limiting (example)\nmcp.use(async (ctx, next) => {\n  const userId = ctx.state.user?.id;\n  if (await isRateLimited(userId)) {\n    throw new Error(\"Rate limit exceeded\");\n  }\n  await next();\n});\n```\n\nInside your tools you can then rely on `ctx.state.user` (or whatever you set) rather than re-validating headers manually. See the [`mcp-lite` middleware docs](https://github.com/modelcontextprotocol/mcp-lite#middleware) for more patterns.\n\n### Best Practices\n\n1. **Enable RLS on all tables:** Ensure all tables have RLS enabled\n2. **Create appropriate policies:** Define policies that match your security requirements\n3. **Monitor edge function logs:** Check logs for suspicious queries or errors\n4. **Rate limiting:** Consider adding rate limiting to prevent abuse\n5. **Query complexity:** Set statement timeouts in Postgres to prevent long-running queries\n6. **Validate tool inputs:** Sanitize and validate every argument received by MCP tools\n\n## Customization\n\n### Change the AI Model\n\nEdit `supabase/functions/chat/index.ts`:\n\n```ts\nconst result = await streamText({\n  model: openai(\"gpt-4o\"), // Change to another model (OpenAI, Anthropic, Google, etc.)\n  // ... rest of config\n});\n```\n\n### Customize the System Prompt\n\nEdit the `system` parameter in `supabase/functions/chat/index.ts` to change the assistant's behavior.\n\n### Style the Widget\n\nAI SDK Elements are standard React components, so you can:\n\n- Override Tailwind classes\n- Reorder or remove sections (e.g., hide the model selector)\n- Inject custom suggestion lists or streaming loaders\n\n### Add More MCP Tools\n\nExtend the MCP server with additional tools in `supabase/functions/mcp-server/index.ts` following the same Hono pattern:\n\n```ts\nmcp.tool(\"myCustomTool\", {\n  description: \"Description of what this tool does\",\n  inputSchema: z.object({\n    param1: z.string(),\n    param2: z.number().optional(),\n  }),\n  handler: async (args, { req }) => {\n    const supabaseClient = createClient(\n      Deno.env.get(\"SUPABASE_URL\") ?? \"\",\n      Deno.env.get(\"SUPABASE_ANON_KEY\") ?? \"\",\n      {\n        global: {\n          headers: { Authorization: req.headers.get(\"Authorization\")! },\n        },\n      }\n    );\n\n    // Tool implementation\n    return {\n      content: [{ type: \"text\", text: \"Result\" }],\n    };\n  },\n});\n```\n\n## Troubleshooting\n\n### \"Unauthorized\" Error\n\n- Ensure the user is authenticated before using the widget\n- Check that `SUPABASE_URL` and `SUPABASE_ANON_KEY` are set correctly\n- Verify the Authorization header is forwarded to the MCP server\n\n### \"Query execution failed\"\n\n- Verify the table exists and is accessible\n- Check that RLS policies allow the user to access the data\n- Verify the column names in filters are correct\n- Check edge function logs: `supabase functions logs mcp-server`\n\n### \"Function not found\" or 404\n\n- Verify the chat function is deployed at `/functions/v1/chat` and `NEXT_PUBLIC_ASSISTANT_CHAT_URL` points to it\n- Make sure the Hono app is mounted at `/mcp-server`\n- Confirm you are calling `/functions/v1/mcp-server/mcp`\n- Restart `supabase functions serve` after changing import maps\n",
      "type": "registry:file",
      "target": "README.assistant.md"
    }
  ]
}