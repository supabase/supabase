{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "assistant",
  "type": "registry:block",
  "title": "AI Assistant with Database Query",
  "description": "AI chatbot widget with database query capabilities through MCP (Model Context Protocol)",
  "dependencies": [
    "ai@latest",
    "@ai-sdk/react@latest",
    "@ai-sdk/openai@latest",
    "@ai-sdk/mcp@latest",
    "@supabase/ssr@latest",
    "@supabase/supabase-js@latest",
    "zod@latest",
    "nanoid@latest",
    "sonner@latest",
    "lucide-react@latest",
    "recharts@latest"
  ],
  "registryDependencies": [
    "button",
    "input",
    "popover",
    "scroll-area",
    "chart",
    "@ai-elements/conversation",
    "@ai-elements/message",
    "@ai-elements/prompt-input",
    "@ai-elements/model-selector",
    "@ai-elements/reasoning",
    "@ai-elements/sources",
    "@ai-elements/suggestion"
  ],
  "files": [
    {
      "path": "registry/default/blocks/assistant/components/assistant-widget.tsx",
      "content": "'use client'\nimport { createClient } from '@/registry/default/blocks/assistant/lib/supabase/client'\nimport {\n  Conversation,\n  ConversationContent,\n  ConversationScrollButton,\n} from '@/registry/default/components/ai-elements/conversation'\nimport {\n  Message,\n  MessageContent,\n  MessageResponse,\n} from '@/registry/default/components/ai-elements/message'\nimport {\n  ModelSelector,\n  ModelSelectorContent,\n  ModelSelectorEmpty,\n  ModelSelectorGroup,\n  ModelSelectorInput,\n  ModelSelectorItem,\n  ModelSelectorList,\n  ModelSelectorLogo,\n  ModelSelectorName,\n  ModelSelectorTrigger,\n} from '@/registry/default/components/ai-elements/model-selector'\nimport {\n  PromptInput,\n  PromptInputBody,\n  PromptInputButton,\n  PromptInputFooter,\n  type PromptInputMessage,\n  PromptInputSubmit,\n  PromptInputTextarea,\n  PromptInputTools,\n} from '@/registry/default/components/ai-elements/prompt-input'\nimport { Suggestion, Suggestions } from '@/registry/default/components/ai-elements/suggestion'\nimport { Button } from '@/registry/default/components/ui/button'\nimport { Popover, PopoverContent, PopoverTrigger } from '@/registry/default/components/ui/popover'\nimport { useChat } from '@ai-sdk/react'\nimport { DefaultChatTransport } from 'ai'\nimport { CheckIcon, MessageCircle } from 'lucide-react'\nimport { useCallback, useState } from 'react'\nimport { toast } from 'sonner'\nimport { Chart, type ChartProps } from './parts/chart'\nimport { Row, type RowItem } from './parts/row'\n\nconst CHAT_API_URL = process.env.NEXT_PUBLIC_CHAT_API_URL\n\nconst models = [\n  {\n    id: 'gpt-5',\n    name: 'GPT-5',\n    chef: 'OpenAI',\n    chefSlug: 'openai',\n    providers: ['openai', 'azure'],\n  },\n  {\n    id: 'gpt-5-mini',\n    name: 'GPT-5 Mini',\n    chef: 'OpenAI',\n    chefSlug: 'openai',\n    providers: ['openai', 'azure'],\n  },\n  {\n    id: 'claude-opus-4-20250514',\n    name: 'Claude 4 Opus',\n    chef: 'Anthropic',\n    chefSlug: 'anthropic',\n    providers: ['anthropic', 'azure', 'google', 'amazon-bedrock'],\n  },\n  {\n    id: 'claude-sonnet-4-20250514',\n    name: 'Claude 4 Sonnet',\n    chef: 'Anthropic',\n    chefSlug: 'anthropic',\n    providers: ['anthropic', 'azure', 'google', 'amazon-bedrock'],\n  },\n  {\n    id: 'gemini-2.0-flash-exp',\n    name: 'Gemini 2.0 Flash',\n    chef: 'Google',\n    chefSlug: 'google',\n    providers: ['google'],\n  },\n]\n\nconst suggestions = [\n  'How many tasks have I completed this week',\n  'Show me active tasks',\n  'Mark all tasks as complete',\n  'Help me plan my day',\n]\n\ntype RenderRowToolInput = {\n  rows: RowItem[]\n}\n\ntype RenderChartToolInput = ChartProps\n\ninterface AssistantWidgetProps {\n  /**\n   * Override the trigger positioning if you need to embed the widget in a scoped container.\n   */\n  triggerClassName?: string\n}\n\nexport const AssistantWidget = ({\n  triggerClassName = 'fixed bottom-6 right-6',\n}: AssistantWidgetProps = {}) => {\n  const [model, setModel] = useState<string>(models[1].id)\n  const [modelSelectorOpen, setModelSelectorOpen] = useState(false)\n  const [text, setText] = useState<string>('')\n  const [useWebSearch, setUseWebSearch] = useState<boolean>(false)\n  const [useMicrophone, setUseMicrophone] = useState<boolean>(false)\n\n  const getAuthHeaders = useCallback(async () => {\n    const supabase = createClient()\n    const {\n      data: { session },\n      error,\n    } = await supabase.auth.getSession()\n\n    if (error) {\n      throw error\n    }\n\n    if (!session) {\n      throw new Error('No active session found. Please sign in.')\n    }\n\n    return {\n      Authorization: `Bearer ${session.access_token}`,\n    }\n  }, [])\n\n  const { messages, sendMessage, status, error } = useChat({\n    transport: new DefaultChatTransport({\n      api: CHAT_API_URL,\n      headers: async () => {\n        try {\n          return await getAuthHeaders()\n        } catch (error) {\n          console.error('Authentication error:', error)\n          toast.error('Failed to authenticate')\n          return {}\n        }\n      },\n      body: () => ({\n        model,\n        useWebSearch,\n      }),\n    }),\n    onError: (error) => {\n      console.error('Chat error:', error)\n      toast.error('Failed to send message', {\n        description: error.message,\n      })\n    },\n    onFinish: () => {\n      // Successfully finished streaming\n    },\n  })\n\n  const selectedModelData = models.find((m) => m.id === model)\n\n  const handleSubmit = useCallback(\n    (message: PromptInputMessage) => {\n      const hasText = Boolean(message.text)\n      const hasAttachments = Boolean(message.files?.length)\n\n      if (!(hasText || hasAttachments)) {\n        return\n      }\n\n      if (message.files?.length) {\n        toast.success('Files attached', {\n          description: `${message.files.length} file(s) attached to message`,\n        })\n      }\n\n      sendMessage({ text: message.text || 'Sent with attachments' })\n      setText('')\n    },\n    [sendMessage]\n  )\n\n  const handleSuggestionClick = useCallback(\n    (suggestion: string) => {\n      sendMessage({ text: suggestion })\n    },\n    [sendMessage]\n  )\n\n  return (\n    <Popover>\n      <PopoverTrigger asChild>\n        <Button\n          aria-label=\"Open assistant\"\n          className={`${triggerClassName} h-12 w-12 rounded-full shadow-lg`}\n          size=\"icon\"\n        >\n          <MessageCircle className=\"h-5 w-5\" />\n        </Button>\n      </PopoverTrigger>\n\n      <PopoverContent\n        align=\"end\"\n        className=\"h-[480px] w-[480px] p-0 flex flex-col gap-0\"\n        side=\"top\"\n        sideOffset={16}\n      >\n        <Conversation className=\"flex-1 border-b\">\n          <ConversationContent>\n            {messages.map(({ role, parts }, index) => (\n              <Message from={role} key={index}>\n                <MessageContent className=\"space-y-4\">\n                  {parts.map((part, i) => {\n                    switch (part.type) {\n                      case 'text':\n                        return <MessageResponse key={`${role}-${i}`}>{part.text}</MessageResponse>\n                      case 'tool-renderRow': {\n                        const payload = (part.input ?? part.output) as\n                          | RenderRowToolInput\n                          | undefined\n                        if (!payload?.rows?.length) return null\n\n                        return (\n                          <Row\n                            key={`${role}-${i}`}\n                            onActionSelect={(prompt) => {\n                              if (prompt) {\n                                sendMessage({ text: prompt })\n                              }\n                            }}\n                            rows={payload.rows}\n                          />\n                        )\n                      }\n                      case 'tool-renderChart': {\n                        console.log('part', part)\n                        const payload = (part.input ?? part.output) as\n                          | RenderChartToolInput\n                          | undefined\n                        if (!payload) return null\n\n                        return <Chart key={`${role}-${i}`} {...payload} />\n                      }\n                      default:\n                        return null\n                    }\n                  })}\n                </MessageContent>\n              </Message>\n            ))}\n          </ConversationContent>\n          <ConversationScrollButton />\n        </Conversation>\n        <Suggestions className=\"p-3\">\n          {suggestions.map((suggestion) => (\n            <Suggestion\n              key={suggestion}\n              onClick={() => handleSuggestionClick(suggestion)}\n              suggestion={suggestion}\n            />\n          ))}\n        </Suggestions>\n        <div className=\"w-full px-4 pb-4\">\n          <PromptInput globalDrop multiple onSubmit={handleSubmit}>\n            <PromptInputBody>\n              <PromptInputTextarea onChange={(event) => setText(event.target.value)} value={text} />\n            </PromptInputBody>\n            <PromptInputFooter>\n              <PromptInputTools>\n                <ModelSelector onOpenChange={setModelSelectorOpen} open={modelSelectorOpen}>\n                  <ModelSelectorTrigger asChild>\n                    <PromptInputButton>\n                      {selectedModelData?.chefSlug && (\n                        <ModelSelectorLogo\n                          className=\"dark:invert\"\n                          provider={selectedModelData.chefSlug}\n                        />\n                      )}\n                      {selectedModelData?.name && (\n                        <ModelSelectorName>{selectedModelData.name}</ModelSelectorName>\n                      )}\n                    </PromptInputButton>\n                  </ModelSelectorTrigger>\n                  <ModelSelectorContent>\n                    <ModelSelectorInput placeholder=\"Search models...\" />\n                    <ModelSelectorList>\n                      <ModelSelectorEmpty>No models found.</ModelSelectorEmpty>\n                      {['OpenAI', 'Anthropic', 'Google'].map((chef) => (\n                        <ModelSelectorGroup key={chef} heading={chef}>\n                          {models\n                            .filter((m) => m.chef === chef)\n                            .map((m) => (\n                              <ModelSelectorItem\n                                key={m.id}\n                                onSelect={() => {\n                                  setModel(m.id)\n                                  setModelSelectorOpen(false)\n                                }}\n                                value={m.id}\n                              >\n                                <ModelSelectorLogo className=\"dark:invert\" provider={m.chefSlug} />\n                                <ModelSelectorName>{m.name}</ModelSelectorName>\n                                {model === m.id ? (\n                                  <CheckIcon className=\"ml-auto size-4\" />\n                                ) : (\n                                  <div className=\"ml-auto size-4\" />\n                                )}\n                              </ModelSelectorItem>\n                            ))}\n                        </ModelSelectorGroup>\n                      ))}\n                    </ModelSelectorList>\n                  </ModelSelectorContent>\n                </ModelSelector>\n              </PromptInputTools>\n              <PromptInputSubmit\n                disabled={!(text.trim() || status) || status === 'streaming'}\n                status={status}\n              />\n            </PromptInputFooter>\n          </PromptInput>\n        </div>\n      </PopoverContent>\n    </Popover>\n  )\n}\n\nexport default AssistantWidget\n",
      "type": "registry:component"
    },
    {
      "path": "registry/default/blocks/assistant/components/parts/row.tsx",
      "content": "'use client'\n\nimport { Button } from '@/registry/default/components/ui/button'\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from '@/registry/default/components/ui/dropdown-menu'\nimport { MoreHorizontal } from 'lucide-react'\n\nexport type RowAction = {\n  label: string\n  prompt: string\n}\n\nexport type RowItem = {\n  primaryText: string\n  secondaryText?: string\n  actions?: RowAction[]\n}\n\nexport type RowProps = {\n  rows: RowItem[]\n  onActionSelect?: (prompt: string) => void\n}\n\nexport function Row({ rows, onActionSelect }: RowProps) {\n  if (!rows.length) return null\n\n  return (\n    <div className=\"space-y-[1px] w-full mb-4 shrink-0\">\n      {rows.map((row, index) => {\n        const hasActions = Boolean(row.actions?.length)\n\n        return (\n          <div\n            className=\"flex items-start justify-between gap-3 first:rounded-t-lg last:rounded-b-lg bg-card px-3 py-3 text-sm w-full\"\n            key={`${row.primaryText}-${index}`}\n          >\n            <div className=\"space-y-1\">\n              <p className=\"font-medium leading-none\">{row.primaryText}</p>\n              {row.secondaryText ? (\n                <p className=\"text-muted-foreground text-xs\">{row.secondaryText}</p>\n              ) : null}\n            </div>\n            {hasActions ? (\n              <DropdownMenu>\n                <DropdownMenuTrigger asChild>\n                  <Button\n                    aria-label=\"Open task actions\"\n                    className=\"h-8 w-8 text-muted-foreground\"\n                    size=\"icon\"\n                    variant=\"ghost\"\n                  >\n                    <MoreHorizontal className=\"h-4 w-4\" />\n                  </Button>\n                </DropdownMenuTrigger>\n                <DropdownMenuContent align=\"end\">\n                  {row.actions?.map((action) => (\n                    <DropdownMenuItem\n                      key={action.label}\n                      className=\"cursor-pointer\"\n                      onSelect={(event) => {\n                        event.preventDefault()\n                        if (action.prompt) {\n                          onActionSelect?.(action.prompt)\n                        }\n                      }}\n                    >\n                      {action.label}\n                    </DropdownMenuItem>\n                  ))}\n                </DropdownMenuContent>\n              </DropdownMenu>\n            ) : null}\n          </div>\n        )\n      })}\n    </div>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/default/blocks/assistant/components/parts/chart.tsx",
      "content": "'use client'\n\nimport {\n  Card,\n  CardContent,\n  CardDescription,\n  CardFooter,\n  CardHeader,\n  CardTitle,\n} from '@/registry/default/components/ui/card'\n\nexport type ChartDataPoint = Record<string, string | number>\n\nexport type ChartProps = {\n  primaryText?: string\n  secondaryText?: string\n  tertiaryText?: string\n  data?: ChartDataPoint[]\n  xAxis?: string\n  yAxis?: string\n}\n\nexport function Chart({\n  primaryText,\n  secondaryText,\n  tertiaryText,\n  data,\n  xAxis,\n  yAxis,\n}: ChartProps) {\n  // Don't render if we don't have the minimum required data\n  const hasMinimumData = Boolean(data && data.length > 0 && xAxis && yAxis)\n\n  // Calculate max value for normalization\n  const maxValue =\n    hasMinimumData && data && yAxis\n      ? Math.max(...data.map((point) => Number(point[yAxis]) || 0))\n      : 0\n\n  return (\n    <Card>\n      <CardHeader>\n        {primaryText ? <CardTitle>{primaryText}</CardTitle> : null}\n        {secondaryText ? <CardDescription>{secondaryText}</CardDescription> : null}\n      </CardHeader>\n      {hasMinimumData && data && xAxis && yAxis ? (\n        <CardContent>\n          <div className=\"flex items-end gap-2 h-[200px] w-full\">\n            {data.map((point, index) => {\n              const value = Number(point[yAxis]) || 0\n              const heightPercentage = maxValue > 0 ? (value / maxValue) * 100 : 0\n              const label = String(point[xAxis] || '').slice(0, 3)\n\n              return (\n                <div key={index} className=\"flex-1 flex flex-col items-center gap-2 h-full\">\n                  <div className=\"w-full flex items-end justify-center flex-1\">\n                    <div\n                      className=\"w-full rounded-lg bg-chart-1 min-h-[4px]\"\n                      style={{ height: `${heightPercentage}%` }}\n                    />\n                  </div>\n                  <div className=\"text-xs text-muted-foreground text-center\">{label}</div>\n                </div>\n              )\n            })}\n          </div>\n        </CardContent>\n      ) : (\n        <CardContent>\n          <div className=\"flex items-center justify-center h-[200px] text-muted-foreground\">\n            Loading chart data...\n          </div>\n        </CardContent>\n      )}\n      {tertiaryText ? (\n        <CardFooter className=\"flex-col items-start gap-2 text-sm\">\n          <div className=\"text-muted-foreground\">{tertiaryText}</div>\n        </CardFooter>\n      ) : null}\n    </Card>\n  )\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/default/blocks/assistant/lib/supabase/server.ts",
      "content": "import { createServerClient } from '@supabase/ssr'\nimport { cookies } from 'next/headers'\n\n/**\n * If using Fluid compute: Don't put this client in a global variable. Always create a new client within each\n * function when using it.\n */\nexport async function createClient() {\n  const cookieStore = await cookies()\n\n  return createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return cookieStore.getAll()\n        },\n        setAll(cookiesToSet) {\n          try {\n            cookiesToSet.forEach(({ name, value, options }) =>\n              cookieStore.set(name, value, options)\n            )\n          } catch {\n            // The `setAll` method was called from a Server Component.\n            // This can be ignored if you have middleware refreshing\n            // user sessions.\n          }\n        },\n      },\n    }\n  )\n}\n",
      "type": "registry:file",
      "target": "lib/supabase/server.ts"
    },
    {
      "path": "registry/default/blocks/assistant/lib/supabase/client.ts",
      "content": "import { createBrowserClient } from '@supabase/ssr'\n\nexport function createClient() {\n  return createBrowserClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n  )\n}\n",
      "type": "registry:file",
      "target": "lib/supabase/client.ts"
    },
    {
      "path": "registry/default/blocks/assistant/lib/supabase/middleware.ts",
      "content": "import { createServerClient } from '@supabase/ssr'\nimport { NextResponse, type NextRequest } from 'next/server'\n\nexport async function updateSession(request: NextRequest) {\n  let supabaseResponse = NextResponse.next({\n    request,\n  })\n\n  const supabase = createServerClient(\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\n    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n    {\n      cookies: {\n        getAll() {\n          return request.cookies.getAll()\n        },\n        setAll(cookiesToSet) {\n          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value))\n          supabaseResponse = NextResponse.next({\n            request,\n          })\n          cookiesToSet.forEach(({ name, value, options }) =>\n            supabaseResponse.cookies.set(name, value, options)\n          )\n        },\n      },\n    }\n  )\n\n  // IMPORTANT: Avoid writing any logic between createServerClient and\n  // supabase.auth.getUser(). A simple mistake could make it very hard to debug\n  // issues with users being randomly logged out.\n\n  const {\n    data: { user },\n  } = await supabase.auth.getUser()\n\n  // IMPORTANT: You *must* return the supabaseResponse object as it is.\n  // If you're creating a new response object with NextResponse.next() make sure to:\n  // 1. Pass the request in it, like so:\n  //    const myNewResponse = NextResponse.next({ request })\n  // 2. Copy over the cookies, like so:\n  //    myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll())\n  // 3. Change the myNewResponse object to fit your needs, but avoid changing\n  //    the cookies!\n  // 4. Finally:\n  //    return myNewResponse\n  // If this is not done, you may be causing the browser and server to go out\n  // of sync and terminate the user's session prematurely.\n\n  return supabaseResponse\n}\n",
      "type": "registry:file",
      "target": "lib/supabase/middleware.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/mcp-server/index.ts",
      "content": "import { Hono } from 'hono'\nimport { McpServer, StreamableHttpTransport } from 'mcp-lite'\nimport { z } from 'zod'\nimport { corsHeaders } from '../_shared/cors.ts'\nimport { createClient } from 'jsr:@supabase/supabase-js@2'\nimport { toolRegistry } from './tools/registry.ts'\n\n// We create two Hono instances:\n// 1. `app` is the root handler for the Supabase Edge Function (must match the function name, e.g. /mcp-server)\n// 2. `mcpApp` handles the MCP protocol and health endpoints, mounted under the function route\n// This pattern is required because Supabase Edge Functions route all requests to /<function-name>/*\n\nconst mcp = new McpServer({\n  name: 'supabase-assistant-mcp-server',\n  version: '1.0.0',\n  schemaAdapter: (schema: unknown) => z.toJSONSchema(schema as z.ZodType),\n})\n\n// Auth Header Management\n// StreamableHttpTransport doesn't expose HTTP request headers to the MCP context (ctx.request.headers is undefined).\n// We use a module-level variable to pass the auth header from the Hono handler to MCP middleware.\n// This is safe because Supabase Edge Functions process requests sequentially, not concurrently.\n// The header is set before processing and cleared in a finally block to prevent leaks.\n// Alternative: Use InMemorySessionAdapter with custom session context, but adds unnecessary complexity.\nlet currentAuthHeader: string | null = null\n\n// Helper function to create authenticated Supabase client\nfunction createAuthenticatedClient(authHeader: string) {\n  return createClient(\n    Deno.env.get('SUPABASE_URL')!,\n    Deno.env.get('SUPABASE_ANON_KEY')!,\n    {\n      global: {\n        headers: {\n          Authorization: authHeader,\n        },\n      },\n    }\n  )\n}\n\n// Middleware to inject auth header into MCP context state\nmcp.use(async (ctx: any, next: any) => {\n  // Try to get auth header from ctx.request.headers (doesn't work with StreamableHttpTransport)\n  // Fall back to the stored currentAuthHeader set by the Hono handler\n  const authHeader = ctx.request?.headers?.get?.('Authorization') || currentAuthHeader\n\n  if (authHeader) {\n    // Make auth header available to all tool handlers via ctx.state\n    ctx.state.authHeader = authHeader\n  }\n\n  await next()\n})\n\ntoolRegistry.forEach((tool) => {\n  mcp.tool(tool.name, {\n    description: tool.description,\n    inputSchema: tool.inputSchema,\n    handler: async (input: unknown, ctx: any) => {\n      const authHeader = ctx.state?.authHeader\n\n      if (!authHeader) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: tool.authErrorMessage,\n            },\n          ],\n          isError: true,\n        }\n      }\n\n      try {\n        const supabase = createAuthenticatedClient(authHeader)\n        return await tool.run(supabase, input)\n      } catch (err) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Unexpected error: ${err instanceof Error ? err.message : String(err)}`,\n            },\n          ],\n          isError: true,\n        }\n      }\n    },\n  })\n})\n\nconst transport = new StreamableHttpTransport()\nconst httpHandler = transport.bind(mcp)\n\nconst app = new Hono()\nconst mcpApp = new Hono()\n\n// Handle OPTIONS requests for CORS\nmcpApp.use('*', async (c, next) => {\n  if (c.req.method === 'OPTIONS') {\n    return new Response('ok', { headers: corsHeaders })\n  }\n  await next()\n})\n\nmcpApp.get('/', (c) => {\n  return c.json({\n    message: 'MCP Server on Supabase Edge Functions',\n    endpoints: {\n      mcp: '/mcp',\n      health: '/health',\n    },\n  })\n})\n\nmcpApp.get('/health', (c) => {\n  return c.json({\n    message: 'Service is up and running',\n  })\n})\n\n// Handle both POST (for regular MCP requests) and GET (for SSE connections)\nconst handleMcpRequest = async (c: any) => {\n  // Validate Authorization header at the Hono level\n  // (StreamableHttpTransport doesn't expose HTTP headers to MCP context)\n  const authHeader = c.req.header('Authorization')\n\n  if (!authHeader) {\n    return c.json({ error: 'Unauthorized' }, { status: 401, headers: corsHeaders })\n  }\n\n  // Store auth header so MCP middleware can inject it into ctx.state for tool handlers\n  currentAuthHeader = authHeader\n\n  try {\n    const response = await httpHandler(c.req.raw)\n    return response\n  } finally {\n    // Clean up auth header after request completes to prevent leaks\n    currentAuthHeader = null\n  }\n}\n\nmcpApp.post('/mcp', handleMcpRequest)\nmcpApp.get('/mcp', handleMcpRequest)\n\n// Mount the MCP app at /mcp-server (matches the function name)\napp.route('/mcp-server', mcpApp)\n\nexport default app\n",
      "type": "registry:file",
      "target": "supabase/functions/mcp-server/index.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/mcp-server/deno.json",
      "content": "{\n  \"compilerOptions\": {\n    \"lib\": [\"deno.window\", \"deno.ns\"],\n    \"strict\": true\n  },\n  \"imports\": {\n    \"hono\": \"npm:hono@4.10.6\",\n    \"mcp-lite\": \"npm:mcp-lite@0.10.0\",\n    \"zod\": \"npm:zod@^4.1.12\",\n    \"@supabase/supabase-js\": \"npm:@supabase/supabase-js@^2\"\n  },\n  \"verify_jwt\": false\n}\n",
      "type": "registry:file",
      "target": "supabase/functions/mcp-server/deno.json"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/chat/index.ts",
      "content": "import { experimental_createMCPClient as createMCPClient } from '@ai-sdk/mcp'\nimport { openai } from '@ai-sdk/openai'\nimport { convertToModelMessages, stepCountIs, streamText } from 'ai'\nimport { corsHeaders } from '../_shared/cors.ts'\nimport { mcpServerRegistry } from './mcp-servers/registry.ts'\nimport { systemPrompt } from './prompt.ts'\nimport { renderTools } from './render-tools.ts'\n\ntype ChatRequestBody = {\n  messages?: unknown[]\n  model?: string\n}\n\nDeno.serve(async (req) => {\n  if (req.method === 'OPTIONS') {\n    return new Response('ok', { headers: corsHeaders })\n  }\n\n  const authHeader = req.headers.get('Authorization')\n  if (!authHeader) {\n    return new Response(JSON.stringify({ error: 'Unauthorized' }), {\n      status: 401,\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n    })\n  }\n\n  let body: ChatRequestBody\n  try {\n    body = await req.json()\n  } catch {\n    return new Response(JSON.stringify({ error: 'Invalid JSON payload' }), {\n      status: 400,\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n    })\n  }\n\n  if (!body.messages || !Array.isArray(body.messages)) {\n    return new Response(JSON.stringify({ error: 'Request must include a messages array' }), {\n      status: 400,\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n    })\n  }\n\n  const modelId = body.model && typeof body.model === 'string' ? body.model : 'gpt-4o'\n\n  let normalizedMessages\n  try {\n    normalizedMessages = convertToModelMessages(body.messages as any)\n  } catch (conversionError) {\n    console.error('Assistant chat message normalization error:', conversionError)\n    return new Response(JSON.stringify({ error: 'Invalid message format' }), {\n      status: 400,\n      headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n    })\n  }\n\n  // Create MCP clients from registry definitions\n  let tools = { ...renderTools }\n  const mcpClients: Array<{ id: string; client: Awaited<ReturnType<typeof createMCPClient>> }> = []\n\n  try {\n    for (const server of mcpServerRegistry) {\n      try {\n        const transport = await server.createTransport({ authHeader })\n        if (!transport) continue\n\n        const client = await createMCPClient({ transport })\n        mcpClients.push({ id: server.id, client })\n\n        const remoteTools = await client.tools()\n        tools = { ...tools, ...remoteTools }\n      } catch (serverError) {\n        console.error(`Failed to initialize MCP server \"${server.id}\":`, serverError)\n      }\n    }\n  } catch (mcpError) {\n    console.error('Unexpected MCP registry initialization error:', mcpError)\n  }\n\n  const closeMcpClients = async () => {\n    await Promise.all(\n      mcpClients.map(async ({ client }) => {\n        try {\n          await client.close()\n        } catch (closeError) {\n          console.error('Error closing MCP client:', closeError)\n        }\n      })\n    )\n  }\n\n  try {\n    const result = await streamText({\n      model: openai(modelId),\n      messages: normalizedMessages,\n      stopWhen: stepCountIs(5),\n      system: systemPrompt,\n      tools,\n      onFinish: async () => {\n        await closeMcpClients()\n      },\n    })\n\n    return result.toUIMessageStreamResponse({\n      headers: corsHeaders,\n      sendReasoning: true,\n      sendSources: true,\n    })\n  } catch (error) {\n    console.error('Assistant chat error:', error)\n\n    await closeMcpClients()\n\n    return new Response(\n      JSON.stringify({\n        error: 'Failed to process chat request',\n        details: error instanceof Error ? error.message : String(error),\n      }),\n      {\n        status: 500,\n        headers: { ...corsHeaders, 'Content-Type': 'application/json' },\n      }\n    )\n  }\n})\n",
      "type": "registry:file",
      "target": "supabase/functions/chat/index.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/chat/mcp-servers/types.ts",
      "content": "import type { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js'\n\nexport type MCPServerContext = {\n  authHeader: string\n}\n\nexport type MCPServerDefinition = {\n  id: string\n  name: string\n  description?: string\n  createTransport: (\n    context: MCPServerContext\n  ) => Promise<StreamableHTTPClientTransport | null> | StreamableHTTPClientTransport | null\n}\n",
      "type": "registry:file",
      "target": "supabase/functions/chat/mcp-servers/types.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/chat/mcp-servers/supabase.ts",
      "content": "import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js'\nimport type { MCPServerDefinition } from './types.ts'\n\nexport const supabaseMcpServer: MCPServerDefinition = {\n  id: 'supabase-edge',\n  name: 'Supabase Edge MCP Server',\n  description: 'Local MCP server that provides Supabase task tools.',\n  createTransport: ({ authHeader }) => {\n    const supabaseUrl = Deno.env.get('SUPABASE_URL')\n    if (!supabaseUrl) {\n      console.warn('SUPABASE_URL is not configured. Skipping Supabase MCP server registration.')\n      return null\n    }\n\n    const normalizedUrl = supabaseUrl.replace(/\\/$/, '')\n    const mcpServerUrl = `${normalizedUrl}/functions/v1/mcp-server/mcp`\n\n    return new StreamableHTTPClientTransport(new URL(mcpServerUrl), {\n      requestInit: {\n        headers: {\n          Authorization: authHeader,\n        },\n      },\n    })\n  },\n}\n",
      "type": "registry:file",
      "target": "supabase/functions/chat/mcp-servers/supabase.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/chat/mcp-servers/registry.ts",
      "content": "import type { MCPServerDefinition } from './types.ts'\nimport { supabaseMcpServer } from './supabase.ts'\n\nexport const mcpServerRegistry: MCPServerDefinition[] = [supabaseMcpServer]\n",
      "type": "registry:file",
      "target": "supabase/functions/chat/mcp-servers/registry.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/chat/prompt.ts",
      "content": "const currentDate = new Date().toISOString().split('T')[0]\n\nexport const systemPrompt = `Today is ${currentDate}. You are Supabase Tasks, an AI assistant focused on helping users plan, prioritize, and manage their work. Keep conversations grounded in their task lists, suggest concrete next actions, and clarify requirements before acting.`\n",
      "type": "registry:file",
      "target": "supabase/functions/chat/prompt.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/chat/deno.json",
      "content": "{\n  \"compilerOptions\": {\n    \"lib\": [\"deno.window\", \"deno.ns\"],\n    \"strict\": true\n  },\n  \"imports\": {\n    \"hono\": \"npm:hono@4.10.6\",\n    \"zod\": \"npm:zod@^4.1.12\",\n    \"ai\": \"npm:ai@^5.0.93\",\n    \"@ai-sdk/openai\": \"npm:@ai-sdk/openai@^2.0.68\",\n    \"@ai-sdk/mcp\": \"npm:@ai-sdk/mcp@latest\",\n    \"@modelcontextprotocol/sdk/client/streamableHttp.js\": \"npm:@modelcontextprotocol/sdk@^1.22.0/client/streamableHttp.js\"\n  }\n}\n",
      "type": "registry:file",
      "target": "supabase/functions/chat/deno.json"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/_shared/cors.ts",
      "content": "export const corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n  'Access-Control-Allow-Methods': 'POST, OPTIONS',\n}\n",
      "type": "registry:file",
      "target": "supabase/functions/_shared/cors.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/chat/render-tools.ts",
      "content": "import { tool } from 'ai'\nimport { z } from 'zod'\n\nconst rowSchema = z.object({\n  primaryText: z.string().describe('Primary label for the row such as the task title.'),\n  secondaryText: z\n    .string()\n    .optional()\n    .describe('Secondary information such as due dates or task metadata.'),\n  actions: z\n    .array(\n      z.object({\n        label: z.string().describe('Text shown in the action menu, e.g., \"Delete task\".'),\n        prompt: z\n          .string()\n          .describe('Prompt to send back to the assistant when the action is selected.'),\n      })\n    )\n    .optional()\n    .describe('Optional list of quick actions the user can trigger for this row.'),\n})\n\nconst chartDataPointSchema = z\n  .object({})\n  .catchall(\n    z\n      .union([z.string(), z.number()])\n      .describe(\n        'Value for this property in the data point. Strings are typically labels, numbers are metrics.'\n      )\n  )\n  .describe('Data point object containing axis and value fields.')\n\nconst chartSchema = z.object({\n  primaryText: z\n    .string()\n    .describe('Primary title shown at the top of the chart card. e.g. Tasks completed'),\n  secondaryText: z\n    .string()\n    .optional()\n    .describe('Optional short description shown under the title. e.g. Last 7 days'),\n  tertiaryText: z\n    .string()\n    .optional()\n    .describe(\n      'Optional supporting text shown beneath the chart. e.g. Increase of 12% week over week'\n    ),\n  data: z.array(chartDataPointSchema).min(1).describe('Data points to plot on the chart.'),\n  xAxis: z\n    .string()\n    .describe('Key inside each data point to use for the X-axis labels (e.g., \"month\").'),\n  yAxis: z\n    .string()\n    .describe('Key inside each data point to use for the bar height values (e.g., \"desktop\").'),\n})\n\nconst renderRowTool = tool({\n  description:\n    'Render a task row to summarize Supabase records, including follow-up actions the user can take.',\n  inputSchema: z.object({\n    rows: z.array(rowSchema).min(1).describe('Rows to display to the user.'),\n  }),\n  execute: async ({ rows }) => {\n    return {\n      success: true,\n      message: 'Rows have been shown to the user',\n    }\n  },\n})\n\nconst renderChartTool = tool({\n  description: 'Render a bar chart summarizing Supabase metrics for the user.',\n  inputSchema: chartSchema,\n  execute: async () => {\n    return {\n      success: true,\n      message: 'Chart has been shown to the user',\n    }\n  },\n})\n\nexport const renderTools = {\n  renderRow: renderRowTool,\n  renderChart: renderChartTool,\n}\n",
      "type": "registry:file",
      "target": "supabase/functions/chat/render-tools.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/mcp-server/tools/count-tasks.ts",
      "content": "import { z } from 'zod'\nimport type { ToolDefinition } from './types.ts'\n\ntype CountTasksInput = {\n  createdAtStart?: string\n  createdAtEnd?: string\n  completedAtStart?: string\n  completedAtEnd?: string\n}\n\nexport const countTasksTool: ToolDefinition<CountTasksInput> = {\n  name: 'countTasks',\n  description:\n    'Count tasks that were created and/or completed between the provided date ranges. Dates should be ISO strings (YYYY-MM-DD or full timestamp).',\n  authErrorMessage: 'Error: Authentication required to count tasks.',\n  inputSchema: z.object({\n    createdAtStart: z\n      .string()\n      .optional()\n      .describe('Lower bound for created_at (inclusive). Accepts ISO dates or timestamps.'),\n    createdAtEnd: z\n      .string()\n      .optional()\n      .describe('Upper bound for created_at (inclusive). Accepts ISO dates or timestamps.'),\n    completedAtStart: z\n      .string()\n      .optional()\n      .describe('Lower bound for completed_at (inclusive). Accepts ISO dates or timestamps.'),\n    completedAtEnd: z\n      .string()\n      .optional()\n      .describe('Upper bound for completed_at (inclusive). Accepts ISO dates or timestamps.'),\n  }),\n  run: async (supabase, { createdAtStart, createdAtEnd, completedAtStart, completedAtEnd }) => {\n    try {\n      const { data, error } = await supabase.rpc('count_tasks', {\n        created_at_start: createdAtStart ?? null,\n        created_at_end: createdAtEnd ?? null,\n        completed_at_start: completedAtStart ?? null,\n        completed_at_end: completedAtEnd ?? null,\n      })\n\n      if (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error counting tasks: ${error.message}`,\n            },\n          ],\n          isError: true,\n        }\n      }\n\n      const total = Array.isArray(data)\n        ? (data[0]?.total as number | undefined) ?? 0\n        : (data as number | null) ?? 0\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Found ${total} task(s) matching the provided filters.`,\n          },\n        ],\n      }\n    } catch (err) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Unexpected error: ${err instanceof Error ? err.message : String(err)}`,\n          },\n        ],\n        isError: true,\n      }\n    }\n  },\n}\n",
      "type": "registry:file",
      "target": "supabase/functions/mcp-server/tools/count-tasks.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/mcp-server/tools/create-task.ts",
      "content": "import { z } from 'zod'\nimport type { ToolDefinition } from './types.ts'\n\ntype CreateTaskInput = {\n  title: string\n  due_date?: string\n}\n\nexport const createTaskTool: ToolDefinition<CreateTaskInput> = {\n  name: 'createTask',\n  description: 'Create a task for the authenticated user. Optionally provide a due date (YYYY-MM-DD).',\n  authErrorMessage: 'Error: Authentication required to create tasks.',\n  inputSchema: z.object({\n    title: z\n      .string()\n      .min(1, 'Title must not be empty')\n      .describe('Task title to display in the list.'),\n    due_date: z\n      .string()\n      .optional()\n      .describe('Optional due date in YYYY-MM-DD format.'),\n  }),\n  run: async (supabase, { title, due_date }) => {\n    try {\n      const {\n        data: { user },\n        error: userError,\n      } = await supabase.auth.getUser()\n\n      if (userError || !user) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error retrieving authenticated user: ${userError?.message ?? 'Not found'}`,\n            },\n          ],\n          isError: true,\n        }\n      }\n\n      const { data, error } = await supabase\n        .from('tasks')\n        .insert({\n          title,\n          due_at: due_date ?? null,\n          assignee_id: user.id,\n        })\n        .select('id, title, due_at, assignee_id')\n        .single()\n\n      if (error || !data) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error creating task: ${error?.message ?? 'Unknown error'}`,\n            },\n          ],\n          isError: true,\n        }\n      }\n\n      const dueDateText = data.due_at ? `Due ${data.due_at}` : 'No due date set'\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Created task [${data.id}] \"${data.title}\" for user ${data.assignee_id}. ${dueDateText}.`,\n          },\n        ],\n      }\n    } catch (err) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Unexpected error: ${err instanceof Error ? err.message : String(err)}`,\n          },\n        ],\n        isError: true,\n      }\n    }\n  },\n}\n",
      "type": "registry:file",
      "target": "supabase/functions/mcp-server/tools/create-task.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/mcp-server/tools/delete-task.ts",
      "content": "import { z } from 'zod'\nimport type { ToolDefinition } from './types.ts'\n\ntype DeleteTaskInput = {\n  id: number\n}\n\nexport const deleteTaskTool: ToolDefinition<DeleteTaskInput> = {\n  name: 'deleteTask',\n  description: 'Delete a task using its numeric id.',\n  authErrorMessage: 'Error: Authentication required to delete tasks.',\n  inputSchema: z.object({\n    id: z.number().int().describe('Task id to delete.'),\n  }),\n  run: async (supabase, { id }) => {\n    try {\n      const { data, error } = await supabase\n        .from('tasks')\n        .delete()\n        .eq('id', id)\n        .select('id, title')\n        .single()\n\n      if (error || !data) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error deleting task: ${error?.message ?? 'Task not found or already deleted.'}`,\n            },\n          ],\n          isError: true,\n        }\n      }\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Deleted task [${data.id}] \"${data.title ?? 'Untitled'}\" successfully.`,\n          },\n        ],\n      }\n    } catch (err) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Unexpected error: ${err instanceof Error ? err.message : String(err)}`,\n          },\n        ],\n        isError: true,\n      }\n    }\n  },\n}\n",
      "type": "registry:file",
      "target": "supabase/functions/mcp-server/tools/delete-task.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/mcp-server/tools/get-user-tasks.ts",
      "content": "import { z } from 'zod'\nimport type { ToolDefinition } from './types.ts'\n\ntype GetUserTasksInput = {\n  due_date?: string\n  title_search?: string\n}\n\nexport const getUserTasksTool: ToolDefinition<GetUserTasksInput> = {\n  name: 'getUserTasks',\n  description:\n    'Fetch tasks for the authenticated user with optional filtering by due date and title search.',\n  authErrorMessage: 'Error: Authentication required to fetch tasks.',\n  inputSchema: z.object({\n    due_date: z\n      .string()\n      .optional()\n      .describe('Optional due date filter in YYYY-MM-DD format. Returns tasks with this exact due date.'),\n    title_search: z\n      .string()\n      .optional()\n      .describe('Optional title search term. Returns tasks where the title contains this text (case-insensitive).'),\n  }),\n  run: async (supabase, { due_date, title_search }) => {\n    try {\n      let query = supabase\n        .from('tasks')\n        .select('id, created_at, title, assignee_id, due_at')\n        .order('due_at', { ascending: true, nullsFirst: false })\n\n      if (due_date) {\n        query = query.eq('due_at', due_date)\n      }\n\n      if (title_search) {\n        query = query.ilike('title', `%${title_search}%`)\n      }\n\n      const { data, error } = await query\n\n      if (error) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error fetching tasks: ${error.message}`,\n            },\n          ],\n          isError: true,\n        }\n      }\n\n      const taskCount = data?.length || 0\n      const tasksText =\n        data && taskCount > 0\n          ? data\n              .map((task) => {\n                const dueDate = task.due_at ? `Due: ${task.due_at}` : 'No due date'\n                return `- [${task.id}] ${task.title || 'Untitled'} (${dueDate})`\n              })\n              .join('\\n')\n          : 'No tasks found.'\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Found ${taskCount} task(s):\\n\\n${tasksText}`,\n          },\n        ],\n      }\n    } catch (err) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Unexpected error: ${err instanceof Error ? err.message : String(err)}`,\n          },\n        ],\n        isError: true,\n      }\n    }\n  },\n}\n",
      "type": "registry:file",
      "target": "supabase/functions/mcp-server/tools/get-user-tasks.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/mcp-server/tools/registry.ts",
      "content": "import { createTaskTool } from './create-task.ts'\nimport { deleteTaskTool } from './delete-task.ts'\nimport { getUserTasksTool } from './get-user-tasks.ts'\nimport { countTasksTool } from './count-tasks.ts'\nimport { updateTaskTool } from './update-task.ts'\nimport type { ToolDefinition } from './types.ts'\n\nexport const toolRegistry: ToolDefinition[] = [\n  getUserTasksTool,\n  createTaskTool,\n  updateTaskTool,\n  deleteTaskTool,\n  countTasksTool,\n]\n",
      "type": "registry:file",
      "target": "supabase/functions/mcp-server/tools/registry.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/mcp-server/tools/types.ts",
      "content": "import type { SupabaseClient } from 'jsr:@supabase/supabase-js@2'\nimport type { ZodTypeAny } from 'zod'\n\nexport interface ToolDefinition<Input = unknown> {\n  name: string\n  description: string\n  inputSchema: ZodTypeAny\n  authErrorMessage: string\n  run: (supabase: SupabaseClient, input: Input) => Promise<any>\n}\n",
      "type": "registry:file",
      "target": "supabase/functions/mcp-server/tools/types.ts"
    },
    {
      "path": "registry/default/blocks/assistant/supabase/functions/mcp-server/tools/update-task.ts",
      "content": "import { z } from 'zod'\nimport type { ToolDefinition } from './types.ts'\n\ntype UpdateTaskInput = {\n  id: number\n  title?: string\n  due_date?: string\n  completed_at?: string\n}\n\nexport const updateTaskTool: ToolDefinition<UpdateTaskInput> = {\n  name: 'updateTask',\n  description: 'Update a task title, due date, and/or completion date by id.',\n  authErrorMessage: 'Error: Authentication required to update tasks.',\n  inputSchema: z\n    .object({\n      id: z.number().int().describe('Task id to update.'),\n      title: z.string().optional().describe('New title for the task.'),\n      due_date: z\n        .string()\n        .optional()\n        .describe('New due date in YYYY-MM-DD format. Set to empty string to clear.'),\n      completed_at: z\n        .string()\n        .optional()\n        .describe(\n          'Completion date in YYYY-MM-DD or ISO timestamp format. Set to empty string to clear.'\n        ),\n    })\n    .refine(\n      (data) =>\n        data.title !== undefined || data.due_date !== undefined || data.completed_at !== undefined,\n      {\n        message: 'Provide at least a title, due_date, or completed_at to update.',\n        path: ['title'],\n      }\n    ),\n  run: async (supabase, { id, title, due_date, completed_at }) => {\n    try {\n      const updatePayload: Record<string, string | null> = {}\n\n      if (title !== undefined) {\n        updatePayload.title = title\n      }\n\n      if (due_date !== undefined) {\n        updatePayload.due_at = due_date || null\n      }\n\n      if (completed_at !== undefined) {\n        updatePayload.completed_at = completed_at || null\n      }\n\n      const { data, error } = await supabase\n        .from('tasks')\n        .update(updatePayload)\n        .eq('id', id)\n        .select('id, title, due_at, completed_at, assignee_id')\n        .single()\n\n      if (error || !data) {\n        return {\n          content: [\n            {\n              type: 'text',\n              text: `Error updating task: ${error?.message ?? 'Task not found.'}`,\n            },\n          ],\n          isError: true,\n        }\n      }\n\n      const dueDateText = data.due_at ? `Due ${data.due_at}` : 'No due date set'\n      const completedText = data.completed_at\n        ? `Completed on ${data.completed_at}`\n        : 'Not completed'\n\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Updated task [${data.id}] \"${data.title}\". ${dueDateText}. ${completedText}.`,\n          },\n        ],\n      }\n    } catch (err) {\n      return {\n        content: [\n          {\n            type: 'text',\n            text: `Unexpected error: ${err instanceof Error ? err.message : String(err)}`,\n          },\n        ],\n        isError: true,\n      }\n    }\n  },\n}\n",
      "type": "registry:file",
      "target": "supabase/functions/mcp-server/tools/update-task.ts"
    }
  ]
}