{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "infinite-query-hook",
  "type": "registry:block",
  "title": "Infinite Query Hook",
  "description": "React hook for infinite lists, fetching data from Supabase.",
  "dependencies": [
    "@supabase/supabase-js",
    "@supabase/postgrest-js@*"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "registry/default/blocks/infinite-query-hook/hooks/use-infinite-query.ts",
      "content": "'use client'\r\n\r\nimport { createClient } from '@/registry/default/fixtures/lib/supabase/client'\r\nimport { PostgrestQueryBuilder } from '@supabase/postgrest-js'\r\nimport { SupabaseClient } from '@supabase/supabase-js'\r\nimport { useEffect, useRef, useSyncExternalStore } from 'react'\r\n\r\nconst supabase = createClient()\r\n\r\n// The following types are used to make the hook type-safe. It extracts the database type from the supabase client.\r\ntype SupabaseClientType = typeof supabase\r\n\r\n// Utility type to check if the type is any\r\ntype IfAny<T, Y, N> = 0 extends 1 & T ? Y : N\r\n\r\n// Extracts the database type from the supabase client. If the supabase client doesn't have a type, it will fallback properly.\r\ntype Database =\r\n  SupabaseClientType extends SupabaseClient<infer U>\r\n    ? IfAny<\r\n        U,\r\n        {\r\n          public: {\r\n            Tables: Record<string, any>\r\n            Views: Record<string, any>\r\n            Functions: Record<string, any>\r\n          }\r\n        },\r\n        U\r\n      >\r\n    : never\r\n\r\n// Change this to the database schema you want to use\r\ntype DatabaseSchema = Database['public']\r\n\r\n// Extracts the table names from the database type\r\ntype SupabaseTableName = keyof DatabaseSchema['Tables']\r\n\r\n// Extracts the table definition from the database type\r\ntype SupabaseTableData<T extends SupabaseTableName> = DatabaseSchema['Tables'][T]['Row']\r\n\r\ntype SupabaseSelectBuilder<T extends SupabaseTableName> = ReturnType<\r\n  PostgrestQueryBuilder<DatabaseSchema, DatabaseSchema['Tables'][T], T>['select']\r\n>\r\n\r\n// A function that modifies the query. Can be used to sort, filter, etc. If .range is used, it will be overwritten.\r\ntype SupabaseQueryHandler<T extends SupabaseTableName> = (\r\n  query: SupabaseSelectBuilder<T>\r\n) => SupabaseSelectBuilder<T>\r\n\r\ninterface UseInfiniteQueryProps<T extends SupabaseTableName, Query extends string = '*'> {\r\n  // The table name to query\r\n  tableName: T\r\n  // The columns to select, defaults to `*`\r\n  columns?: string\r\n  // The number of items to fetch per page, defaults to `20`\r\n  pageSize?: number\r\n  // A function that modifies the query. Can be used to sort, filter, etc. If .range is used, it will be overwritten.\r\n  trailingQuery?: SupabaseQueryHandler<T>\r\n}\r\n\r\ninterface StoreState<TData> {\r\n  data: TData[]\r\n  count: number\r\n  isSuccess: boolean\r\n  isLoading: boolean\r\n  isFetching: boolean\r\n  error: Error | null\r\n  hasInitialFetch: boolean\r\n}\r\n\r\ntype Listener = () => void\r\n\r\nfunction createStore<TData extends SupabaseTableData<T>, T extends SupabaseTableName>(\r\n  props: UseInfiniteQueryProps<T>\r\n) {\r\n  const { tableName, columns = '*', pageSize = 20, trailingQuery } = props\r\n\r\n  let state: StoreState<TData> = {\r\n    data: [],\r\n    count: 0,\r\n    isSuccess: false,\r\n    isLoading: false,\r\n    isFetching: false,\r\n    error: null,\r\n    hasInitialFetch: false,\r\n  }\r\n\r\n  const listeners = new Set<Listener>()\r\n\r\n  const notify = () => {\r\n    listeners.forEach((listener) => listener())\r\n  }\r\n\r\n  const setState = (newState: Partial<StoreState<TData>>) => {\r\n    state = { ...state, ...newState }\r\n    notify()\r\n  }\r\n\r\n  const fetchPage = async (skip: number) => {\r\n    if (state.hasInitialFetch && (state.isFetching || state.count <= state.data.length)) return\r\n\r\n    setState({ isFetching: true })\r\n\r\n    let query = supabase\r\n      .from(tableName)\r\n      .select(columns, { count: 'exact' }) as unknown as SupabaseSelectBuilder<T>\r\n\r\n    if (trailingQuery) {\r\n      query = trailingQuery(query)\r\n    }\r\n    const { data: newData, count, error } = await query.range(skip, skip + pageSize - 1)\r\n\r\n    if (error) {\r\n      console.error('An unexpected error occurred:', error)\r\n      setState({ error })\r\n    } else {\r\n      const deduplicatedData = ((newData || []) as TData[]).filter(\r\n        (item) => !state.data.find((old) => old.id === item.id)\r\n      )\r\n\r\n      setState({\r\n        data: [...state.data, ...deduplicatedData],\r\n        count: count || 0,\r\n        isSuccess: true,\r\n        error: null,\r\n      })\r\n    }\r\n    setState({ isFetching: false })\r\n  }\r\n\r\n  const fetchNextPage = async () => {\r\n    if (state.isFetching) return\r\n    await fetchPage(state.data.length)\r\n  }\r\n\r\n  const initialize = async () => {\r\n    setState({ isLoading: true, isSuccess: false, data: [] })\r\n    await fetchNextPage()\r\n    setState({ isLoading: false, hasInitialFetch: true })\r\n  }\r\n\r\n  return {\r\n    getState: () => state,\r\n    subscribe: (listener: Listener) => {\r\n      listeners.add(listener)\r\n      return () => listeners.delete(listener)\r\n    },\r\n    fetchNextPage,\r\n    initialize,\r\n  }\r\n}\r\n\r\n// Empty initial state to avoid hydration errors.\r\nconst initialState: any = {\r\n  data: [],\r\n  count: 0,\r\n  isSuccess: false,\r\n  isLoading: false,\r\n  isFetching: false,\r\n  error: null,\r\n  hasInitialFetch: false,\r\n}\r\n\r\nfunction useInfiniteQuery<\r\n  TData extends SupabaseTableData<T>,\r\n  T extends SupabaseTableName = SupabaseTableName,\r\n>(props: UseInfiniteQueryProps<T>) {\r\n  const storeRef = useRef(createStore<TData, T>(props))\r\n\r\n  const state = useSyncExternalStore(\r\n    storeRef.current.subscribe,\r\n    () => storeRef.current.getState(),\r\n    () => initialState as StoreState<TData>\r\n  )\r\n\r\n  useEffect(() => {\r\n    // Recreate store if props change\r\n    if (\r\n      storeRef.current.getState().hasInitialFetch &&\r\n      (props.tableName !== props.tableName ||\r\n        props.columns !== props.columns ||\r\n        props.pageSize !== props.pageSize)\r\n    ) {\r\n      storeRef.current = createStore<TData, T>(props)\r\n    }\r\n\r\n    if (!state.hasInitialFetch && typeof window !== 'undefined') {\r\n      storeRef.current.initialize()\r\n    }\r\n  }, [props.tableName, props.columns, props.pageSize, state.hasInitialFetch])\r\n\r\n  return {\r\n    data: state.data,\r\n    count: state.count,\r\n    isSuccess: state.isSuccess,\r\n    isLoading: state.isLoading,\r\n    isFetching: state.isFetching,\r\n    error: state.error,\r\n    hasMore: state.count > state.data.length,\r\n    fetchNextPage: storeRef.current.fetchNextPage,\r\n  }\r\n}\r\n\r\nexport {\r\n  useInfiniteQuery,\r\n  type SupabaseQueryHandler,\r\n  type SupabaseTableData,\r\n  type SupabaseTableName,\r\n  type UseInfiniteQueryProps,\r\n}\r\n",
      "type": "registry:hook"
    }
  ]
}