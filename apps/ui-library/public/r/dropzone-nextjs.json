{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "dropzone-nextjs",
  "type": "registry:component",
  "title": "Dropzone (File Upload)",
  "description": "Displays a control for easier uploading of files directly to Supabase Storage.",
  "dependencies": [
    "react-dropzone",
    "lucide-react",
    "@supabase/ssr@latest",
    "@supabase/supabase-js@latest"
  ],
  "registryDependencies": [
    "button"
  ],
  "files": [
    {
      "path": "registry/default/blocks/dropzone/components/dropzone.tsx",
      "content": "'use client'\r\n\r\nimport { cn } from '@/lib/utils'\r\nimport { type UseSupabaseUploadReturn } from '@/registry/default/blocks/dropzone/hooks/use-supabase-upload'\r\nimport { Button } from '@/registry/default/components/ui/button'\r\nimport { CheckCircle, File, Loader2, Upload, X } from 'lucide-react'\r\nimport { createContext, type PropsWithChildren, useCallback, useContext } from 'react'\r\n\r\nexport const formatBytes = (\r\n  bytes: number,\r\n  decimals = 2,\r\n  size?: 'bytes' | 'KB' | 'MB' | 'GB' | 'TB' | 'PB' | 'EB' | 'ZB' | 'YB'\r\n) => {\r\n  const k = 1000\r\n  const dm = decimals < 0 ? 0 : decimals\r\n  const sizes = ['bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\r\n\r\n  if (bytes === 0 || bytes === undefined) return size !== undefined ? `0 ${size}` : '0 bytes'\r\n  const i = size !== undefined ? sizes.indexOf(size) : Math.floor(Math.log(bytes) / Math.log(k))\r\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i]\r\n}\r\n\r\ntype DropzoneContextType = Omit<UseSupabaseUploadReturn, 'getRootProps' | 'getInputProps'>\r\n\r\nconst DropzoneContext = createContext<DropzoneContextType | undefined>(undefined)\r\n\r\ntype DropzoneProps = UseSupabaseUploadReturn & {\r\n  className?: string\r\n}\r\n\r\nconst Dropzone = ({\r\n  className,\r\n  children,\r\n  getRootProps,\r\n  getInputProps,\r\n  ...restProps\r\n}: PropsWithChildren<DropzoneProps>) => {\r\n  const isSuccess = restProps.isSuccess\r\n  const isActive = restProps.isDragActive\r\n  const isInvalid =\r\n    (restProps.isDragActive && restProps.isDragReject) ||\r\n    (restProps.errors.length > 0 && !restProps.isSuccess) ||\r\n    restProps.files.some((file) => file.errors.length !== 0)\r\n\r\n  return (\r\n    <DropzoneContext.Provider value={{ ...restProps }}>\r\n      <div\r\n        {...getRootProps({\r\n          className: cn(\r\n            'border-2 border-gray-300 rounded-lg p-6 text-center bg-card transition-colors duration-300 text-foreground',\r\n            className,\r\n            isSuccess ? 'border-solid' : 'border-dashed',\r\n            isActive && 'border-primary bg-primary/10',\r\n            isInvalid && 'border-destructive bg-destructive/10'\r\n          ),\r\n        })}\r\n      >\r\n        <input {...getInputProps()} />\r\n        {children}\r\n      </div>\r\n    </DropzoneContext.Provider>\r\n  )\r\n}\r\nconst DropzoneContent = ({ className }: { className?: string }) => {\r\n  const {\r\n    files,\r\n    setFiles,\r\n    onUpload,\r\n    loading,\r\n    successes,\r\n    errors,\r\n    maxFileSize,\r\n    maxFiles,\r\n    isSuccess,\r\n  } = useDropzoneContext()\r\n\r\n  const exceedMaxFiles = files.length > maxFiles\r\n\r\n  const handleRemoveFile = useCallback(\r\n    (fileName: string) => {\r\n      setFiles(files.filter((file) => file.name !== fileName))\r\n    },\r\n    [files, setFiles]\r\n  )\r\n\r\n  if (isSuccess) {\r\n    return (\r\n      <div className={cn('flex flex-row items-center gap-x-2 justify-center', className)}>\r\n        <CheckCircle size={16} className=\"text-primary\" />\r\n        <p className=\"text-primary text-sm\">\r\n          Successfully uploaded {files.length} file{files.length > 1 ? 's' : ''}\r\n        </p>\r\n      </div>\r\n    )\r\n  }\r\n\r\n  return (\r\n    <div className={cn('flex flex-col', className)}>\r\n      {files.map((file, idx) => {\r\n        const fileError = errors.find((e) => e.name === file.name)\r\n        const isSuccessfullyUploaded = !!successes.find((e) => e === file.name)\r\n\r\n        return (\r\n          <div\r\n            key={`${file.name}-${idx}`}\r\n            className=\"flex items-center gap-x-4 border-b py-2 first:mt-4 last:mb-4 \"\r\n          >\r\n            {file.type.startsWith('image/') ? (\r\n              <div className=\"h-10 w-10 rounded border overflow-hidden shrink-0 bg-muted flex items-center justify-center\">\r\n                <img src={file.preview} alt={file.name} className=\"object-cover\" />\r\n              </div>\r\n            ) : (\r\n              <div className=\"h-10 w-10 rounded border bg-muted flex items-center justify-center\">\r\n                <File size={18} />\r\n              </div>\r\n            )}\r\n\r\n            <div className=\"shrink grow flex flex-col items-start truncate\">\r\n              <p title={file.name} className=\"text-sm truncate max-w-full\">\r\n                {file.name}\r\n              </p>\r\n              {file.errors.length > 0 ? (\r\n                <p className=\"text-xs text-destructive\">\r\n                  {file.errors\r\n                    .map((e) =>\r\n                      e.message.startsWith('File is larger than')\r\n                        ? `File is larger than ${formatBytes(maxFileSize, 2)} (Size: ${formatBytes(file.size, 2)})`\r\n                        : e.message\r\n                    )\r\n                    .join(', ')}\r\n                </p>\r\n              ) : loading && !isSuccessfullyUploaded ? (\r\n                <p className=\"text-xs text-muted-foreground\">Uploading file...</p>\r\n              ) : !!fileError ? (\r\n                <p className=\"text-xs text-destructive\">Failed to upload: {fileError.message}</p>\r\n              ) : isSuccessfullyUploaded ? (\r\n                <p className=\"text-xs text-primary\">Successfully uploaded file</p>\r\n              ) : (\r\n                <p className=\"text-xs text-muted-foreground\">{formatBytes(file.size, 2)}</p>\r\n              )}\r\n            </div>\r\n\r\n            {!loading && !isSuccessfullyUploaded && (\r\n              <Button\r\n                size=\"icon\"\r\n                variant=\"link\"\r\n                className=\"shrink-0 justify-self-end text-muted-foreground hover:text-foreground\"\r\n                onClick={() => handleRemoveFile(file.name)}\r\n              >\r\n                <X />\r\n              </Button>\r\n            )}\r\n          </div>\r\n        )\r\n      })}\r\n      {exceedMaxFiles && (\r\n        <p className=\"text-sm text-left mt-2 text-destructive\">\r\n          You may upload only up to {maxFiles} files, please remove {files.length - maxFiles} file\r\n          {files.length - maxFiles > 1 ? 's' : ''}.\r\n        </p>\r\n      )}\r\n      {files.length > 0 && !exceedMaxFiles && (\r\n        <div className=\"mt-2\">\r\n          <Button\r\n            variant=\"outline\"\r\n            onClick={onUpload}\r\n            disabled={files.some((file) => file.errors.length !== 0) || loading}\r\n          >\r\n            {loading ? (\r\n              <>\r\n                <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\r\n                Uploading...\r\n              </>\r\n            ) : (\r\n              <>Upload files</>\r\n            )}\r\n          </Button>\r\n        </div>\r\n      )}\r\n    </div>\r\n  )\r\n}\r\n\r\nconst DropzoneEmptyState = ({ className }: { className?: string }) => {\r\n  const { maxFiles, maxFileSize, inputRef, isSuccess } = useDropzoneContext()\r\n\r\n  if (isSuccess) {\r\n    return null\r\n  }\r\n\r\n  return (\r\n    <div className={cn('flex flex-col items-center gap-y-2', className)}>\r\n      <Upload size={20} className=\"text-muted-foreground\" />\r\n      <p className=\"text-sm\">\r\n        Upload{!!maxFiles && maxFiles > 1 ? ` ${maxFiles}` : ''} file\r\n        {!maxFiles || maxFiles > 1 ? 's' : ''}\r\n      </p>\r\n      <div className=\"flex flex-col items-center gap-y-1\">\r\n        <p className=\"text-xs text-muted-foreground\">\r\n          Drag and drop or{' '}\r\n          <a\r\n            onClick={() => inputRef.current?.click()}\r\n            className=\"underline cursor-pointer transition hover:text-foreground\"\r\n          >\r\n            select {maxFiles === 1 ? `file` : 'files'}\r\n          </a>{' '}\r\n          to upload\r\n        </p>\r\n        {maxFileSize !== Number.POSITIVE_INFINITY && (\r\n          <p className=\"text-xs text-muted-foreground\">\r\n            Maximum file size: {formatBytes(maxFileSize, 2)}\r\n          </p>\r\n        )}\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n\r\nconst useDropzoneContext = () => {\r\n  const context = useContext(DropzoneContext)\r\n\r\n  if (!context) {\r\n    throw new Error('useDropzoneContext must be used within a Dropzone')\r\n  }\r\n\r\n  return context\r\n}\r\n\r\nexport { Dropzone, DropzoneContent, DropzoneEmptyState, useDropzoneContext }\r\n",
      "type": "registry:component"
    },
    {
      "path": "registry/default/blocks/dropzone/hooks/use-supabase-upload.ts",
      "content": "import { createClient } from '@/registry/default/clients/nextjs/lib/supabase/client'\r\nimport { useCallback, useEffect, useMemo, useState } from 'react'\r\nimport { type FileError, type FileRejection, useDropzone } from 'react-dropzone'\r\n\r\nconst supabase = createClient()\r\n\r\ninterface FileWithPreview extends File {\r\n  preview?: string\r\n  errors: readonly FileError[]\r\n}\r\n\r\ntype UseSupabaseUploadOptions = {\r\n  /**\r\n   * Name of bucket to upload files to in your Supabase project\r\n   */\r\n  bucketName: string\r\n  /**\r\n   * Folder to upload files to in the specified bucket within your Supabase project.\r\n   *\r\n   * Defaults to uploading files to the root of the bucket\r\n   *\r\n   * e.g If specified path is `test`, your file will be uploaded as `test/file_name`\r\n   */\r\n  path?: string\r\n  /**\r\n   * Allowed MIME types for each file upload (e.g `image/png`, `text/html`, etc). Wildcards are also supported (e.g `image/*`).\r\n   *\r\n   * Defaults to allowing uploading of all MIME types.\r\n   */\r\n  allowedMimeTypes?: string[]\r\n  /**\r\n   * Maximum upload size of each file allowed in bytes. (e.g 1000 bytes = 1 KB)\r\n   */\r\n  maxFileSize?: number\r\n  /**\r\n   * Maximum number of files allowed per upload.\r\n   */\r\n  maxFiles?: number\r\n  /**\r\n   * The number of seconds the asset is cached in the browser and in the Supabase CDN.\r\n   *\r\n   * This is set in the Cache-Control: max-age=<seconds> header. Defaults to 3600 seconds.\r\n   */\r\n  cacheControl?: number\r\n  /**\r\n   * When set to true, the file is overwritten if it exists.\r\n   *\r\n   * When set to false, an error is thrown if the object already exists. Defaults to `false`\r\n   */\r\n  upsert?: boolean\r\n}\r\n\r\ntype UseSupabaseUploadReturn = ReturnType<typeof useSupabaseUpload>\r\n\r\nconst useSupabaseUpload = (options: UseSupabaseUploadOptions) => {\r\n  const {\r\n    bucketName,\r\n    path,\r\n    allowedMimeTypes = [],\r\n    maxFileSize = Number.POSITIVE_INFINITY,\r\n    maxFiles = 1,\r\n    cacheControl = 3600,\r\n    upsert = false,\r\n  } = options\r\n\r\n  const [files, setFiles] = useState<FileWithPreview[]>([])\r\n  const [loading, setLoading] = useState<boolean>(false)\r\n  const [errors, setErrors] = useState<{ name: string; message: string }[]>([])\r\n  const [successes, setSuccesses] = useState<string[]>([])\r\n\r\n  const isSuccess = useMemo(() => {\r\n    if (errors.length === 0 && successes.length === 0) {\r\n      return false\r\n    }\r\n    if (errors.length === 0 && successes.length === files.length) {\r\n      return true\r\n    }\r\n    return false\r\n  }, [errors.length, successes.length, files.length])\r\n\r\n  const onDrop = useCallback(\r\n    (acceptedFiles: File[], fileRejections: FileRejection[]) => {\r\n      const validFiles = acceptedFiles\r\n        .filter((file) => !files.find((x) => x.name === file.name))\r\n        .map((file) => {\r\n          ;(file as FileWithPreview).preview = URL.createObjectURL(file)\r\n          ;(file as FileWithPreview).errors = []\r\n          return file as FileWithPreview\r\n        })\r\n\r\n      const invalidFiles = fileRejections.map(({ file, errors }) => {\r\n        ;(file as FileWithPreview).preview = URL.createObjectURL(file)\r\n        ;(file as FileWithPreview).errors = errors\r\n        return file as FileWithPreview\r\n      })\r\n\r\n      const newFiles = [...files, ...validFiles, ...invalidFiles]\r\n\r\n      setFiles(newFiles)\r\n    },\r\n    [files, setFiles]\r\n  )\r\n\r\n  const dropzoneProps = useDropzone({\r\n    onDrop,\r\n    noClick: true,\r\n    accept: allowedMimeTypes.reduce((acc, type) => ({ ...acc, [type]: [] }), {}),\r\n    maxSize: maxFileSize,\r\n    maxFiles: maxFiles,\r\n    multiple: maxFiles !== 1,\r\n  })\r\n\r\n  const onUpload = useCallback(async () => {\r\n    setLoading(true)\r\n\r\n    // [Joshen] This is to support handling partial successes\r\n    // If any files didn't upload for any reason, hitting \"Upload\" again will only upload the files that had errors\r\n    const filesWithErrors = errors.map((x) => x.name)\r\n    const filesToUpload =\r\n      filesWithErrors.length > 0\r\n        ? [\r\n            ...files.filter((f) => filesWithErrors.includes(f.name)),\r\n            ...files.filter((f) => !successes.includes(f.name)),\r\n          ]\r\n        : files\r\n\r\n    const responses = await Promise.all(\r\n      filesToUpload.map(async (file) => {\r\n        const { error } = await supabase.storage\r\n          .from(bucketName)\r\n          .upload(!!path ? `${path}/${file.name}` : file.name, file, {\r\n            cacheControl: cacheControl.toString(),\r\n            upsert,\r\n          })\r\n        if (error) {\r\n          return { name: file.name, message: error.message }\r\n        } else {\r\n          return { name: file.name, message: undefined }\r\n        }\r\n      })\r\n    )\r\n\r\n    const responseErrors = responses.filter((x) => x.message !== undefined)\r\n    // if there were errors previously, this function tried to upload the files again so we should clear/overwrite the existing errors.\r\n    setErrors(responseErrors)\r\n\r\n    const responseSuccesses = responses.filter((x) => x.message === undefined)\r\n    const newSuccesses = Array.from(\r\n      new Set([...successes, ...responseSuccesses.map((x) => x.name)])\r\n    )\r\n    setSuccesses(newSuccesses)\r\n\r\n    setLoading(false)\r\n  }, [files, path, bucketName, errors, successes])\r\n\r\n  useEffect(() => {\r\n    if (files.length === 0) {\r\n      setErrors([])\r\n    }\r\n\r\n    // If the number of files doesn't exceed the maxFiles parameter, remove the error 'Too many files' from each file\r\n    if (files.length <= maxFiles) {\r\n      let changed = false\r\n      const newFiles = files.map((file) => {\r\n        if (file.errors.some((e) => e.code === 'too-many-files')) {\r\n          file.errors = file.errors.filter((e) => e.code !== 'too-many-files')\r\n          changed = true\r\n        }\r\n        return file\r\n      })\r\n      if (changed) {\r\n        setFiles(newFiles)\r\n      }\r\n    }\r\n  }, [files.length, setFiles, maxFiles])\r\n\r\n  return {\r\n    files,\r\n    setFiles,\r\n    successes,\r\n    isSuccess,\r\n    loading,\r\n    errors,\r\n    setErrors,\r\n    onUpload,\r\n    maxFileSize: maxFileSize,\r\n    maxFiles: maxFiles,\r\n    allowedMimeTypes,\r\n    ...dropzoneProps,\r\n  }\r\n}\r\n\r\nexport { useSupabaseUpload, type UseSupabaseUploadOptions, type UseSupabaseUploadReturn }\r\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/default/clients/nextjs/lib/supabase/client.ts",
      "content": "import { createBrowserClient } from '@supabase/ssr'\r\n\r\nexport function createClient() {\r\n  return createBrowserClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY!\r\n  )\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/default/clients/nextjs/lib/supabase/middleware.ts",
      "content": "import { createServerClient } from '@supabase/ssr'\r\nimport { NextResponse, type NextRequest } from 'next/server'\r\n\r\nexport async function updateSession(request: NextRequest) {\r\n  let supabaseResponse = NextResponse.next({\r\n    request,\r\n  })\r\n\r\n  // With Fluid compute, don't put this client in a global environment\r\n  // variable. Always create a new one on each request.\r\n  const supabase = createServerClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY!,\r\n    {\r\n      cookies: {\r\n        getAll() {\r\n          return request.cookies.getAll()\r\n        },\r\n        setAll(cookiesToSet) {\r\n          cookiesToSet.forEach(({ name, value }) => request.cookies.set(name, value))\r\n          supabaseResponse = NextResponse.next({\r\n            request,\r\n          })\r\n          cookiesToSet.forEach(({ name, value, options }) =>\r\n            supabaseResponse.cookies.set(name, value, options)\r\n          )\r\n        },\r\n      },\r\n    }\r\n  )\r\n\r\n  // Do not run code between createServerClient and\r\n  // supabase.auth.getClaims(). A simple mistake could make it very hard to debug\r\n  // issues with users being randomly logged out.\r\n\r\n  // IMPORTANT: If you remove getClaims() and you use server-side rendering\r\n  // with the Supabase client, your users may be randomly logged out.\r\n  const { data } = await supabase.auth.getClaims()\r\n  const user = data?.claims\r\n\r\n  if (\r\n    !user &&\r\n    !request.nextUrl.pathname.startsWith('/login') &&\r\n    !request.nextUrl.pathname.startsWith('/auth')\r\n  ) {\r\n    // no user, potentially respond by redirecting the user to the login page\r\n    const url = request.nextUrl.clone()\r\n    url.pathname = '/auth/login'\r\n    return NextResponse.redirect(url)\r\n  }\r\n\r\n  // IMPORTANT: You *must* return the supabaseResponse object as it is.\r\n  // If you're creating a new response object with NextResponse.next() make sure to:\r\n  // 1. Pass the request in it, like so:\r\n  //    const myNewResponse = NextResponse.next({ request })\r\n  // 2. Copy over the cookies, like so:\r\n  //    myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll())\r\n  // 3. Change the myNewResponse object to fit your needs, but avoid changing\r\n  //    the cookies!\r\n  // 4. Finally:\r\n  //    return myNewResponse\r\n  // If this is not done, you may be causing the browser and server to go out\r\n  // of sync and terminate the user's session prematurely!\r\n\r\n  return supabaseResponse\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/default/clients/nextjs/lib/supabase/server.ts",
      "content": "import { createServerClient } from '@supabase/ssr'\r\nimport { cookies } from 'next/headers'\r\n\r\n/**\r\n * If using Fluid compute: Don't put this client in a global variable. Always create a new client within each\r\n * function when using it.\r\n */\r\nexport async function createClient() {\r\n  const cookieStore = await cookies()\r\n\r\n  return createServerClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY!,\r\n    {\r\n      cookies: {\r\n        getAll() {\r\n          return cookieStore.getAll()\r\n        },\r\n        setAll(cookiesToSet) {\r\n          try {\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              cookieStore.set(name, value, options)\r\n            )\r\n          } catch {\r\n            // The `setAll` method was called from a Server Component.\r\n            // This can be ignored if you have middleware refreshing\r\n            // user sessions.\r\n          }\r\n        },\r\n      },\r\n    }\r\n  )\r\n}\r\n",
      "type": "registry:lib"
    }
  ],
  "envVars": {
    "NEXT_PUBLIC_SUPABASE_URL": "",
    "NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY": ""
  },
  "docs": "You'll need to set the following environment variables in your project: `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY`."
}