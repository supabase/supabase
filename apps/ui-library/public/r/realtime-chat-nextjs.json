{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "realtime-chat-nextjs",
  "type": "registry:component",
  "title": "Realtime Chat",
  "description": "Component which renders realtime chat messages from other users in a room.",
  "dependencies": [
    "lucide-react",
    "@supabase/ssr@latest",
    "@supabase/supabase-js@latest"
  ],
  "registryDependencies": [
    "input",
    "button"
  ],
  "files": [
    {
      "path": "registry/default/blocks/realtime-chat/components/chat-message.tsx",
      "content": "import { cn } from '@/lib/utils'\r\nimport type { ChatMessage } from '@/registry/default/blocks/realtime-chat/hooks/use-realtime-chat'\r\n\r\ninterface ChatMessageItemProps {\r\n  message: ChatMessage\r\n  isOwnMessage: boolean\r\n  showHeader: boolean\r\n}\r\n\r\nexport const ChatMessageItem = ({ message, isOwnMessage, showHeader }: ChatMessageItemProps) => {\r\n  return (\r\n    <div className={`flex mt-2 ${isOwnMessage ? 'justify-end' : 'justify-start'}`}>\r\n      <div\r\n        className={cn('max-w-[75%] w-fit flex flex-col gap-1', {\r\n          'items-end': isOwnMessage,\r\n        })}\r\n      >\r\n        {showHeader && (\r\n          <div\r\n            className={cn('flex items-center gap-2 text-xs px-3', {\r\n              'justify-end flex-row-reverse': isOwnMessage,\r\n            })}\r\n          >\r\n            <span className={'font-medium'}>{message.user.name}</span>\r\n            <span className=\"text-foreground/50 text-xs\">\r\n              {new Date(message.createdAt).toLocaleTimeString('en-US', {\r\n                hour: '2-digit',\r\n                minute: '2-digit',\r\n                hour12: true,\r\n              })}\r\n            </span>\r\n          </div>\r\n        )}\r\n        <div\r\n          className={cn(\r\n            'py-2 px-3 rounded-xl text-sm w-fit',\r\n            isOwnMessage ? 'bg-primary text-primary-foreground' : 'bg-muted text-foreground'\r\n          )}\r\n        >\r\n          {message.content}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "registry/default/blocks/realtime-chat/components/realtime-chat.tsx",
      "content": "'use client'\r\n\r\nimport { cn } from '@/lib/utils'\r\nimport { ChatMessageItem } from '@/registry/default/blocks/realtime-chat/components/chat-message'\r\nimport { useChatScroll } from '@/registry/default/blocks/realtime-chat/hooks/use-chat-scroll'\r\nimport {\r\n  type ChatMessage,\r\n  useRealtimeChat,\r\n} from '@/registry/default/blocks/realtime-chat/hooks/use-realtime-chat'\r\nimport { Button } from '@/registry/default/components/ui/button'\r\nimport { Input } from '@/registry/default/components/ui/input'\r\nimport { Send } from 'lucide-react'\r\nimport { useCallback, useEffect, useMemo, useState } from 'react'\r\n\r\ninterface RealtimeChatProps {\r\n  roomName: string\r\n  username: string\r\n  onMessage?: (messages: ChatMessage[]) => void\r\n  messages?: ChatMessage[]\r\n}\r\n\r\n/**\r\n * Realtime chat component\r\n * @param roomName - The name of the room to join. Each room is a unique chat.\r\n * @param username - The username of the user\r\n * @param onMessage - The callback function to handle the messages. Useful if you want to store the messages in a database.\r\n * @param messages - The messages to display in the chat. Useful if you want to display messages from a database.\r\n * @returns The chat component\r\n */\r\nexport const RealtimeChat = ({\r\n  roomName,\r\n  username,\r\n  onMessage,\r\n  messages: initialMessages = [],\r\n}: RealtimeChatProps) => {\r\n  const { containerRef, scrollToBottom } = useChatScroll()\r\n\r\n  const {\r\n    messages: realtimeMessages,\r\n    sendMessage,\r\n    isConnected,\r\n  } = useRealtimeChat({\r\n    roomName,\r\n    username,\r\n  })\r\n  const [newMessage, setNewMessage] = useState('')\r\n\r\n  // Merge realtime messages with initial messages\r\n  const allMessages = useMemo(() => {\r\n    const mergedMessages = [...initialMessages, ...realtimeMessages]\r\n    // Remove duplicates based on message id\r\n    const uniqueMessages = mergedMessages.filter(\r\n      (message, index, self) => index === self.findIndex((m) => m.id === message.id)\r\n    )\r\n    // Sort by creation date\r\n    const sortedMessages = uniqueMessages.sort((a, b) => a.createdAt.localeCompare(b.createdAt))\r\n\r\n    return sortedMessages\r\n  }, [initialMessages, realtimeMessages])\r\n\r\n  useEffect(() => {\r\n    if (onMessage) {\r\n      onMessage(allMessages)\r\n    }\r\n  }, [allMessages, onMessage])\r\n\r\n  useEffect(() => {\r\n    // Scroll to bottom whenever messages change\r\n    scrollToBottom()\r\n  }, [allMessages, scrollToBottom])\r\n\r\n  const handleSendMessage = useCallback(\r\n    (e: React.FormEvent) => {\r\n      e.preventDefault()\r\n      if (!newMessage.trim() || !isConnected) return\r\n\r\n      sendMessage(newMessage)\r\n      setNewMessage('')\r\n    },\r\n    [newMessage, isConnected, sendMessage]\r\n  )\r\n\r\n  return (\r\n    <div className=\"flex flex-col h-full w-full bg-background text-foreground antialiased\">\r\n      {/* Messages */}\r\n      <div ref={containerRef} className=\"flex-1 overflow-y-auto p-4 space-y-4\">\r\n        {allMessages.length === 0 ? (\r\n          <div className=\"text-center text-sm text-muted-foreground\">\r\n            No messages yet. Start the conversation!\r\n          </div>\r\n        ) : null}\r\n        <div className=\"space-y-1\">\r\n          {allMessages.map((message, index) => {\r\n            const prevMessage = index > 0 ? allMessages[index - 1] : null\r\n            const showHeader = !prevMessage || prevMessage.user.name !== message.user.name\r\n\r\n            return (\r\n              <div\r\n                key={message.id}\r\n                className=\"animate-in fade-in slide-in-from-bottom-4 duration-300\"\r\n              >\r\n                <ChatMessageItem\r\n                  message={message}\r\n                  isOwnMessage={message.user.name === username}\r\n                  showHeader={showHeader}\r\n                />\r\n              </div>\r\n            )\r\n          })}\r\n        </div>\r\n      </div>\r\n\r\n      <form onSubmit={handleSendMessage} className=\"flex w-full gap-2 border-t border-border p-4\">\r\n        <Input\r\n          className={cn(\r\n            'rounded-full bg-background text-sm transition-all duration-300',\r\n            isConnected && newMessage.trim() ? 'w-[calc(100%-36px)]' : 'w-full'\r\n          )}\r\n          type=\"text\"\r\n          value={newMessage}\r\n          onChange={(e) => setNewMessage(e.target.value)}\r\n          placeholder=\"Type a message...\"\r\n          disabled={!isConnected}\r\n        />\r\n        {isConnected && newMessage.trim() && (\r\n          <Button\r\n            className=\"aspect-square rounded-full animate-in fade-in slide-in-from-right-4 duration-300\"\r\n            type=\"submit\"\r\n            disabled={!isConnected}\r\n          >\r\n            <Send className=\"size-4\" />\r\n          </Button>\r\n        )}\r\n      </form>\r\n    </div>\r\n  )\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "registry/default/blocks/realtime-chat/hooks/use-realtime-chat.tsx",
      "content": "'use client'\r\n\r\nimport { createClient } from '@/registry/default/clients/nextjs/lib/supabase/client'\r\nimport { useCallback, useEffect, useState } from 'react'\r\n\r\ninterface UseRealtimeChatProps {\r\n  roomName: string\r\n  username: string\r\n}\r\n\r\nexport interface ChatMessage {\r\n  id: string\r\n  content: string\r\n  user: {\r\n    name: string\r\n  }\r\n  createdAt: string\r\n}\r\n\r\nconst EVENT_MESSAGE_TYPE = 'message'\r\n\r\nexport function useRealtimeChat({ roomName, username }: UseRealtimeChatProps) {\r\n  const supabase = createClient()\r\n  const [messages, setMessages] = useState<ChatMessage[]>([])\r\n  const [channel, setChannel] = useState<ReturnType<typeof supabase.channel> | null>(null)\r\n  const [isConnected, setIsConnected] = useState(false)\r\n\r\n  useEffect(() => {\r\n    const newChannel = supabase.channel(roomName)\r\n\r\n    newChannel\r\n      .on('broadcast', { event: EVENT_MESSAGE_TYPE }, (payload) => {\r\n        setMessages((current) => [...current, payload.payload as ChatMessage])\r\n      })\r\n      .subscribe(async (status) => {\r\n        if (status === 'SUBSCRIBED') {\r\n          setIsConnected(true)\r\n        }\r\n      })\r\n\r\n    setChannel(newChannel)\r\n\r\n    return () => {\r\n      supabase.removeChannel(newChannel)\r\n    }\r\n  }, [roomName, username, supabase])\r\n\r\n  const sendMessage = useCallback(\r\n    async (content: string) => {\r\n      if (!channel || !isConnected) return\r\n\r\n      const message: ChatMessage = {\r\n        id: crypto.randomUUID(),\r\n        content,\r\n        user: {\r\n          name: username,\r\n        },\r\n        createdAt: new Date().toISOString(),\r\n      }\r\n\r\n      // Update local state immediately for the sender\r\n      setMessages((current) => [...current, message])\r\n\r\n      await channel.send({\r\n        type: 'broadcast',\r\n        event: EVENT_MESSAGE_TYPE,\r\n        payload: message,\r\n      })\r\n    },\r\n    [channel, isConnected, username]\r\n  )\r\n\r\n  return { messages, sendMessage, isConnected }\r\n}\r\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/default/blocks/realtime-chat/hooks/use-chat-scroll.tsx",
      "content": "import { useCallback, useRef } from 'react'\r\n\r\nexport function useChatScroll() {\r\n  const containerRef = useRef<HTMLDivElement>(null)\r\n\r\n  const scrollToBottom = useCallback(() => {\r\n    if (!containerRef.current) return\r\n\r\n    const container = containerRef.current\r\n    container.scrollTo({\r\n      top: container.scrollHeight,\r\n      behavior: 'smooth',\r\n    })\r\n  }, [])\r\n\r\n  return { containerRef, scrollToBottom }\r\n}\r\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/default/clients/nextjs/lib/supabase/client.ts",
      "content": "import { createBrowserClient } from '@supabase/ssr'\r\n\r\nexport function createClient() {\r\n  return createBrowserClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY!\r\n  )\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/default/clients/nextjs/lib/supabase/middleware.ts",
      "content": "import { createServerClient } from '@supabase/ssr'\r\nimport { NextResponse, type NextRequest } from 'next/server'\r\n\r\nexport async function updateSession(request: NextRequest) {\r\n  let supabaseResponse = NextResponse.next({\r\n    request,\r\n  })\r\n\r\n  // With Fluid compute, don't put this client in a global environment\r\n  // variable. Always create a new one on each request.\r\n  const supabase = createServerClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY!,\r\n    {\r\n      cookies: {\r\n        getAll() {\r\n          return request.cookies.getAll()\r\n        },\r\n        setAll(cookiesToSet) {\r\n          cookiesToSet.forEach(({ name, value }) => request.cookies.set(name, value))\r\n          supabaseResponse = NextResponse.next({\r\n            request,\r\n          })\r\n          cookiesToSet.forEach(({ name, value, options }) =>\r\n            supabaseResponse.cookies.set(name, value, options)\r\n          )\r\n        },\r\n      },\r\n    }\r\n  )\r\n\r\n  // Do not run code between createServerClient and\r\n  // supabase.auth.getClaims(). A simple mistake could make it very hard to debug\r\n  // issues with users being randomly logged out.\r\n\r\n  // IMPORTANT: If you remove getClaims() and you use server-side rendering\r\n  // with the Supabase client, your users may be randomly logged out.\r\n  const { data } = await supabase.auth.getClaims()\r\n  const user = data?.claims\r\n\r\n  if (\r\n    !user &&\r\n    !request.nextUrl.pathname.startsWith('/login') &&\r\n    !request.nextUrl.pathname.startsWith('/auth')\r\n  ) {\r\n    // no user, potentially respond by redirecting the user to the login page\r\n    const url = request.nextUrl.clone()\r\n    url.pathname = '/auth/login'\r\n    return NextResponse.redirect(url)\r\n  }\r\n\r\n  // IMPORTANT: You *must* return the supabaseResponse object as it is.\r\n  // If you're creating a new response object with NextResponse.next() make sure to:\r\n  // 1. Pass the request in it, like so:\r\n  //    const myNewResponse = NextResponse.next({ request })\r\n  // 2. Copy over the cookies, like so:\r\n  //    myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll())\r\n  // 3. Change the myNewResponse object to fit your needs, but avoid changing\r\n  //    the cookies!\r\n  // 4. Finally:\r\n  //    return myNewResponse\r\n  // If this is not done, you may be causing the browser and server to go out\r\n  // of sync and terminate the user's session prematurely!\r\n\r\n  return supabaseResponse\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/default/clients/nextjs/lib/supabase/server.ts",
      "content": "import { createServerClient } from '@supabase/ssr'\r\nimport { cookies } from 'next/headers'\r\n\r\n/**\r\n * If using Fluid compute: Don't put this client in a global variable. Always create a new client within each\r\n * function when using it.\r\n */\r\nexport async function createClient() {\r\n  const cookieStore = await cookies()\r\n\r\n  return createServerClient(\r\n    process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY!,\r\n    {\r\n      cookies: {\r\n        getAll() {\r\n          return cookieStore.getAll()\r\n        },\r\n        setAll(cookiesToSet) {\r\n          try {\r\n            cookiesToSet.forEach(({ name, value, options }) =>\r\n              cookieStore.set(name, value, options)\r\n            )\r\n          } catch {\r\n            // The `setAll` method was called from a Server Component.\r\n            // This can be ignored if you have middleware refreshing\r\n            // user sessions.\r\n          }\r\n        },\r\n      },\r\n    }\r\n  )\r\n}\r\n",
      "type": "registry:lib"
    }
  ],
  "envVars": {
    "NEXT_PUBLIC_SUPABASE_URL": "",
    "NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY": ""
  },
  "docs": "You'll need to set the following environment variables in your project: `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_PUBLISHABLE_OR_ANON_KEY`."
}