---
title: 'Flutter Authentication and Authorization with RLS'
description: Learn how you can secure your Flutter app using Supabase Row Level Security.
author: tyler_shukert
image: flutter-chat-auth/supabase-flutter-auth.jpeg
thumb: flutter-chat-auth/supabase-flutter-auth.jpeg
tags:
  - flutter
  - auth
  - mobile
date: '2022-11-17'
toc_depth: 3
---

This article is the second part of the Flutter tutorial series. During the series, you will learn how to build cross-platform apps without worrying about the backend.

In this article, I will show you how you can make a secure chat application by introducing authentication and authorization to the basic chat app that we created [previously](/blog/flutter-tutorial-building-a-chat-app).

We will use [Supabase](/) to store the chat data and will use its [auth feature](https://supabase.com/auth) to provide a secure chat room feature. Supabase lets us build a secure database where we can control who can access what part of the database, so your users’ data is secured without worrying about the backend. 

## What we created in the previous article

Before we jump in, let’s go over what we built in the [previous article](blog/flutter-tutorial-building-a-chat-app), because we will be building on top of it. If you have not gone through it, I recommend you to go check it out. 

In the previous article, we created a basic real-time chat application. Users will register or sign in using an email address and password. Once they are signed in, they are taken to a chat page, where they can view and send messages to everyone in the app. There are no Chat rooms, and everyone’s messages were sent to the same chat room. 

![Chat app without authorization](/images/blog/flutter-chat-auth/chat-app-screenshot.png)

## Overview of the final app

The app will allow us to have 1 on 1 chat with other users in the app. To enable this, we will introduce a new rooms page. The rooms page serves two purposes here, one is to initiate a conversation with other users, and the other is to display existing chat rooms. At the top of the app, we see a list of other users’ icons. A user can tap the icon to start a 1 on 1 conversation. Below the icons, there is a list of rooms that the user is a part of. 

![Chat app without authorization](/images/blog/flutter-chat-auth/rooms-and-chat-page.png)

## Sessing up the scene

### Install additional dependencies

We will install flutter_bloc for state management. Introducing a state management solution will allow us to handle the shared message and profile data efficiently between the rooms page and the chats page. We can use any state management solution for this, but we are going with bloc in this example. 

```dart
[flutter_bloc installation code here]
```

### Modifying the table schema

Since the app has evolved, we also need to update our table schema. In order to store rooms data, we will add a rooms table. We will also modify the messages table to add a foreign key constraint to the rooms table so that we can tell which message belongs to which room.

We will also intorudce a `create_new_room` function, which is a [database function](/docs/guides/database/functions) that handles chat room creation. It knows to create a new room if a chat room with the two users does not exist yet, or to just return the room ID if it already exists. 

```sql
[SQL here]
```

### Setup deep links

Something we skipped in the previous article was sending confirmation emails to users when they signup. Since today is about security, let's properly send confirmation emails to people who signup. 

When we send confirmation emails, the users need to be brought back to the app somehow. We will use deep links to do so. 

```xml
[Deep link set up code here]
```

supabase-flutter SDK had a built-in mechanism to handle incoming deep links, this is all we need to do to bring the users back.

## Building out the main application

### Step1: Create rooms page

The rooms page will load two types of data, recently added users and a list of rooms that the user belongs to. We will be using bloc to load these two types of data and display them on the rooms page. 

Let’s start out by creating states for the rooms page. The rooms page would have four different states, loading, loaded, empty, and error. We will display different UI on the rooms page depending on what state it is.

```dart
[code for rooms_state]
```

Now that we have the states defined, we will create rooms_cubit. A [cubit](https://bloclibrary.dev/#/coreconcepts?id=cubit) is a class within the flutter_bloc library where we will make requests to Supabase to get the data and transform them into states and emit them to the UI widgets. 


```dart
[code for rooms_cubit]
```

Now that we have the states and cubit to power our rooms page, it’s time to create the `RoomsPage`. 

We have two list views, one horizontal list view to display other users, and one vertical list views with list tiles representing each room that the user is a part of. 

```dart
[code for RoomsPage]
```