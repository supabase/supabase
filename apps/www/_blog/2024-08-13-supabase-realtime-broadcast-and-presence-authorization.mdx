---
title: 'Realtime Broadcast and Presence Authorization'
description: 'Create Authorization policies for Realtime Broadcast and Presence'
author: filipe
image: 2024-08-13-supabase-realtime-broadcast-and-presence-authorization/OG.png
thumb: 2024-08-13-supabase-realtime-broadcast-and-presence-authorization/thumb.png
categories:
tags:
  - realtime
  - engineering
date: '2024-08-13'
toc_depth: 2
---

Today we're releasing Realtime Authorization for Broadcast and Presence in Public Beta.

For context, Supabase includes three useful extensions for building real-time applications.

1. [Broadcast](https://supabase.com/docs/guides/realtime/broadcast): Send ephemeral, low-latency messages between users.
2. [Presence](https://supabase.com/docs/guides/realtime/presence): Show when users are online and share state between users.
3. [Postgres Changes](https://supabase.com/docs/guides/realtime/postgres-changes): Listen to Postgres database changes.

This release introduces authorization for Broadcast and Presence using Row Level Security policies:

```sql
create policy "authenticated user can listen to all messages"
on "realtime"."messages"
as permissive for select
to authenticated
using ( true );
```

To facilitate authorization in Realtime, a new table `realtime.messages` is created automatically by Supabase Realtime when it connects to your Database. This table represents your [Channels](/docs/guides/realtime/concepts#channels) as objects against which you can write RLS policies.

<Img
  src={{
    dark: '/images/blog/2024-08-13-supabase-realtime-broadcast-and-presence-authorization/schema--dark.png',
    light:
      '/images/blog/2024-08-13-supabase-realtime-broadcast-and-presence-authorization/schema--light.png',
  }}
  alt="The table that is used to test the policies."
/>

You can write Postgres RLS policies for this table and Realtime will use it them control the access to
Broadcast and Presence for your channels based on the operations set in your policies:

- `SELECT` policies - Able to receive messages from the channel
- `INSERT` policies - Able to send messages to the channel

## How it works without Authorization

When you want to connect to a Realtime Channel, you do something close to the following code:

```tsx
// With authenticated user token
client.realtime.setAuth(token)

client.channel('channel').subscribe((status: string, err: any) => {
  if (status === 'SUBSCRIBED') {
    console.log('Connected')
  }
})
```

This will enable you to send messages but they will all be public. Any user would be subscribe to this Channel and read these messages if they had your anon token.

## Adding Authorization to Realtime Channels

To convert this into a Realtime Channel that checks RLS policies requires only two steps:

- [Create RLS Policies](#create-rls-policies)
- [Enabling Authorization on Channel subscription](#enabling-authorization-on-channel-subscription)

### Create RLS policies

Any RLS policy will work. Reference our [Github Discussion](github.com/orgs/supabase/discussions/22484) for more complex use cases.

With this example we'll keep it simple and allow authenticated users to connect to a channel, send and receive Broadcast messages and track Presence.

```sql
create policy "authenticated user listen to all"
on "realtime"."messages"
as permissive for select
to authenticated
using ( true );

create policy "authenticated user write to all"
on "realtime"."messages"
as permissive for insert
to authenticated
with check ( true );
```

We also have a new database function called `realtime.topic()` which enables you to write Policies that take into consideration the name of the Channel trying to run the RLS Policy.

```sql
create policy "authenticated users can only read from 'locked' topic"
on "realtime"."messages"
as permissive for select
to authenticated
using ( realtime.topic() = 'locked' );
```

### Enabling Authorization on Channel subscription

Now that you have your RLS policies set, you will need to define on your Channel subscription that you intend to use a private channel. To achieve it we've introduced a new configuration parameter `private` to signal to Realtime servers that you want to check authorization on the channel.

If you try to subscribe with an unauthorized user you will get a new error message informing the user that they do not have permission to access the topic.

```tsx
// With anon user
supabase.realtime
  .channel('locked', { config: { private: true } })
  .subscribe((status: string, err: any) => {
    if (status === 'CHANNEL_ERROR') {
      console.error(err.message)
    }
  })

// Outputs the following error:
// "You do not have permissions to read from this Topic"
```

But if you connect with an authorized user you will be able to listen to all messages from the “locked” topic

```tsx
// With an authenticated user
supabase.realtime.setAuth(token)

supabase.realtime
  .channel('locked', { config: { private: true } })
  .subscribe((status: string, err: any) => {
    if (status === 'CHANNEL_ERROR') {
      console.error(err.message)
    }
  })
```

### Advanced examples

You can find a more complex example in the [Supabase demo folder](https://github.com/supabase/supabase/tree/master/examples/realtime/nextjs-authorization-demo) where we are using this feature to build chat rooms with restricted access.

## How does it work?

We decided on an approach that keeps your database and RLS policies at the heart of this new authorization strategy.

### Database as a source of security

To achieve Realtime authorization, we looked into our current solutions, namely how [Storage](https://supabase.com/docs/guides/storage/security/access-control) handles Access Control. Due to the nature of Realtime, our primitives are different as we have no assets stored in the database. So how did we achieve it?

On Channel subscription you are able to inform Realtime to use a private Channel and we will do the required checks.

The checks are done by running SELECT and INSERT queries on the new `realtime.messages` table which are then rolled backed so nothing is persisted. Then, based on the query result, we can determine the policies the user has for a given extension.

As a result, in the server, we create a map of policies per connected socket so we can keep them in memory associated with the user's connection.

```elixir
%Policies{
  broadcast: %BroadcastPolicies{read: false, write: false},
  presence: %PresencePolicies{read: false, write: false}
}
```

### One user, one context, one connection

Now that we have set up everything on the database side, let's understand how it works and how we can verify authorization via RLS policies.

Upon channel subscription, based on the configuration message sent when joining the websocket, we determine that you want to use a private channel, then we parse the information from your signed JSON Web Token (JWT), load them into a Postgres transaction using `set_config`, and verify them against the new `realtime.messages`table within the same transaction and we store the output as a group of policies within the context of the user's channel process.

<Img
  src={{
    dark: '/images/blog/2024-08-13-supabase-realtime-broadcast-and-presence-authorization/one-user-connection--dark.png',
    light:
      '/images/blog/2024-08-13-supabase-realtime-broadcast-and-presence-authorization/one-user-connection--light.png',
  }}
  alt="Flow of checks done against the databse to determine the policies for a user connection."
/>
## How does this scale?

Since we're doing this as soon as the user subscribes to Channel we should see a small latency increase in subscriptions but after that we do not run any queries on the database and we use the stored context to control the actions a user can perform.

Latency between geographically close users is very important for a product like Realtime. To deliver messages as fast as possible between users on our global network, we cache the policies.

We can maintain high throughput and low latency on a Realtime Channel with Broadcast and Presence authorization because:

- the policy is only generated when a user connects to a Channel
- the policy cached in memory is close to your users
- the policy is cached for the duration of the connection or until the JWT expires

Another added bonus is the fact that if a user does not have access to a given Channel they won't be able to connect at all and their connections will be rejected.

### Refreshing your Policies

Realtime already has a mechanism to check valid refreshed JWTs used by your connection as a way to ensure the user connected continues to be valid. Now, we've added a step where we re-authorize the user by querying your database's `realtime.messages` table when Realtime receives a new user token. This is to make sure the already connected user continues to be authorized even when you've updated RLS policies.

### Postgres Changes Support

This method for Realtime Authorization currently only supports Broadcast and Presence. Postgres Changes already adheres to RLS policies on the tables you're listening to so you can continue using that authorization scheme for getting changes from your database.

## Availability

Broadcast and Presence Authorization is available in Public Beta. We are looking for feedback so please do share it in the [GitHub discussion](github.com/orgs/supabase/discussions/22484).

## Future Work

We're excited to make Realtime more secure, performant, and stable.

We'll take your feedback, expand this approach, and continue to improve the developer experience as you implement Realtime Authorization for your use cases.
