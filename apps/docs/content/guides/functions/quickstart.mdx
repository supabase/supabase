---
id: 'functions-quickstart'
title: 'Developing Edge Functions with Supabase'
description: 'Get started with Edge Functions on the Supabase dashboard.'
subtitle: 'Get started with Edge Functions on the Supabase dashboard.'
tocVideo: '5OWH9c4u68M'
---

In this guide we'll cover how to create a basic Edge Function on the Supabase dashboard, and access it using the Supabase CLI.

## Deploy from Dashboard

Go to your project > Edge Functions > Deploy a new function > Via Editor

<Image
  alt="Deploy functions from the dashboard"
  src={{
    light: '/docs/img/guides/functions/dashboard/deploy-function--light.png',
    dark: '/docs/img/guides/functions/dashboard/deploy-function--light.png',
  }}
  zoomable
/>

This will scaffold a new function for you.

<Image
  alt="Scaffold functions through the dashboard editor"
  src={{
    light: '/docs/img/guides/functions/dashboard/scaffold-function--light.png',
    dark: '/docs/img/guides/functions/dashboard/scaffold-function--light.png',
  }}
  zoomable
/>

Modify the function as needed, name it, and click `Deploy function`

That's it! Your function is now active. Use the endpoint on the function's Details page to call the edge function.

## Access deployed functions via Supabase CLI

<Admonition type="tip" label="CLI not installed?">

Check out the [CLI Docs](/docs/guides/cli) to learn how to install the Supabase CLI on your local machine.

</Admonition>

Now that your function is deployed, you can access it from your local development environment.
Here's how:

1. **Link your project** to your local environment.

   You can find your project reference ID in the URL of your Supabase dashboard or in the project settings.

   ```bash
   supabase link --project-ref your-project-ref
   ```

2. **List all Functions** in the linked Supabase project.

   ```bash
   supabase functions list
   ```

3. **Access the specific function** you want to work on.

   ```bash
   supabase functions download function-name
   ```

4. **Make local edits** to the function code as needed.

5. **Run your function locally** before redeploying.

   ```bash
   supabase functions serve function-name
   ```

6. **Redeploy** when you're ready with your changes.

   ```bash
   supabase functions deploy function-name
   ```

## Deploy via Assistant

You can also leverage the Supabase Assistant to help you write and deploy edge functions.

Go to your project > Edge Functions > Click on the Assistant icon to Create with Supabase Assistant

<Image
  alt="Open Supabase Assistant"
  src={{
    light: '/docs/img/guides/functions/dashboard/create-with-assistant--light.png',
    dark: '/docs/img/guides/functions/dashboard/create-with-assistant--light.png',
  }}
  zoomable
/>

This brings up an assistant window with a pre-filled prompt for generating edge functions.
Write up your Edge Function requirement, and let Supabase Assistant do the rest.

<div style={{ width: '75%', position: 'relative', aspectRatio: 'auto' }}>
  <Image
    alt="Generate a function with the assistant"
    src={{
      light: '/docs/img/guides/functions/dashboard/assistant-function-gen--light.png',
      dark: '/docs/img/guides/functions/dashboard/assistant-function-gen--light.png',
    }}
    zoomable
  />
</div>

Click Deploy and the Assistant will automatically deploy your function.

This function requires an OpenAI API key. You can add the key in your Edge Functions secrets page, or ask Assistant for help.

1. Navigate to your Edge Functions > Secrets page.
2. Look for the option to add environment variables.
3. Add a new environment variable with the key `OPENAI_API_KEY` and set its value to your actual OpenAI API key.

Once you've set this environment variable, your edge functions will be able to access the OPENAI_API_KEY securely without hardcoding it into the function code. This is a best practice for keeping sensitive information safe.

With your variable set, you can test by sending a request via the dashboard. Navigate to the function's details page, and click on the test button. Then provide a Request Body your function expects.

<div style={{ width: '60%', position: 'relative', aspectRatio: 'auto' }}>
  <Image
    alt="Provide a request body to test your function"
    src={{
      light: '/docs/img/guides/functions/dashboard/test-request-body--light.png',
      dark: '/docs/img/guides/functions/dashboard/test-request-body--light.png',
    }}
    zoomable
  />
</div>

## Editing functions from the Dashboard

<Admonition type="caution" label="Be careful: there is currently no version control for edits">

The Dashboard's Edge Function editor currently does not support versioning or rollbacks. We recommend using it only for quick testing and prototypes. When you’re ready to go to production, store Edge Functions code in a source code repository (e.g., git) and deploy it using one of the [CI integrations](https://supabase.com/docs/guides/functions/cicd-workflow).

</Admonition>

1. From the functions page, click on the function you want to edit. From the function page, click on the Code tab.

2. This opens up a code editor in the dashboard where you can see your deployed function's code.

3. Modify the code as needed, then click Deploy updates. This will overwrite the existing deployment with the newly edited function code.

## Next steps

Check out the [Local development](/docs/guides/functions/local-quickstart) guide for more details on working with Edge Functions.

Read on for some common development tips.

## Development tips

Here are a few recommendations when developing Edge Functions.

### Skipping authorization checks

By default, Edge Functions require a valid JWT in the authorization header. If you want to use Edge Functions without Authorization checks (commonly used for Stripe webhooks), you can pass the `--no-verify-jwt` flag when serving your Edge Functions locally.

```bash
supabase functions serve hello-world --no-verify-jwt
```

Be careful when using this flag, as it will allow anyone to invoke your Edge Function without a valid JWT. The Supabase client libraries automatically handle authorization.

### Using HTTP methods

Edge Functions support `GET`, `POST`, `PUT`, `PATCH`, `DELETE`, and `OPTIONS`. A Function can be designed to perform different actions based on a request's HTTP method. See the [example on building a RESTful service](https://github.com/supabase/supabase/tree/master/examples/edge-functions/supabase/functions/restful-tasks) to learn how to handle different HTTP methods in your Function.

<Admonition type="caution" label="HTML not supported">

HTML content is not supported. `GET` requests that return `text/html` will be rewritten to `text/plain`.

</Admonition>

### Naming Edge Functions

We recommend using hyphens to name functions because hyphens are the most URL-friendly of all the naming conventions (snake_case, camelCase, PascalCase).

### Organizing your Edge Functions

We recommend developing "fat functions". This means that you should develop few large functions, rather than many small functions. One common pattern when developing Functions is that you need to share code between two or more Functions. To do this, you can store any shared code in a folder prefixed with an underscore (`_`). We also recommend a separate folder for [Unit Tests](/docs/guides/functions/unit-test) including the name of the function followed by a `-test` suffix.
We recommend this folder structure:

```bash
└── supabase
    ├── functions
    │   ├── import_map.json # A top-level import map to use across functions.
    │   ├── _shared
    │   │   ├── supabaseAdmin.ts # Supabase client with SERVICE_ROLE key.
    │   │   └── supabaseClient.ts # Supabase client with ANON key.
    │   │   └── cors.ts # Reusable CORS headers.
    │   ├── function-one # Use hyphens to name functions.
    │   │   └── index.ts
    │   └── function-two
    │   │   └── index.ts
    │   └── tests
    │       └── function-one-test.ts
    │       └── function-two-test.ts
    ├── migrations
    └── config.toml
```

### Using config.toml

Individual function configuration like [JWT verification](/docs/guides/cli/config#functions.function_name.verify_jwt) and [import map location](/docs/guides/cli/config#functions.function_name.import_map) can be set via the `config.toml` file.

```toml supabase/config.toml
[functions.hello-world]
verify_jwt = false
import_map = './import_map.json'
```

### Not using TypeScript

When you create a new Edge Function, it will use TypeScript by default. However, it is possible to write and deploy Edge Functions using pure JavaScript.

Save your Function as a JavaScript file (e.g. `index.js`) and then update the `supabase/config.toml` as follows:

<Admonition type="note">

`entrypoint` is available only in Supabase CLI version 1.215.0 or higher.

</Admonition>

```toml supabase/config.toml
[functions.hello-world]
# other entries
entrypoint = './functions/hello-world/index.js' # path must be relative to config.toml
```

You can use any `.ts`, `.js`, `.tsx`, `.jsx` or `.mjs` file as the `entrypoint` for a Function.

### Error handling

The `supabase-js` library provides several error types that you can use to handle errors that might occur when invoking Edge Functions:

```js
import { FunctionsHttpError, FunctionsRelayError, FunctionsFetchError } from '@supabase/supabase-js'

const { data, error } = await supabase.functions.invoke('hello', {
  headers: { 'my-custom-header': 'my-custom-header-value' },
  body: { foo: 'bar' },
})

if (error instanceof FunctionsHttpError) {
  const errorMessage = await error.context.json()
  console.log('Function returned an error', errorMessage)
} else if (error instanceof FunctionsRelayError) {
  console.log('Relay error:', error.message)
} else if (error instanceof FunctionsFetchError) {
  console.log('Fetch error:', error.message)
}
```

### Database Functions vs Edge Functions

For data-intensive operations we recommend using [Database Functions](/docs/guides/database/functions), which are executed within your database and can be called remotely using the [REST and GraphQL API](/docs/guides/api).

For use-cases which require low-latency we recommend [Edge Functions](/docs/guides/functions), which are globally-distributed and can be written in TypeScript.
