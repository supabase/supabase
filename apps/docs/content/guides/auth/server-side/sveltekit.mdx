---
title: 'Setting up Server-Side Auth for SvelteKit'
hideToc: true
---

Set up Server-Side Auth to use cookie-based authentication with SvelteKit.

<StepHikeCompact>

<StepHikeCompact.Step step={1}>

<StepHikeCompact.Details title="Install Supabase packages">

Install the `@supabase/supabase-js` package and the helper `@supabase/ssr` package.

</StepHikeCompact.Details>

<StepHikeCompact.Code>

```sh
npm install @supabase/supabase-js @supabase/ssr
```

</StepHikeCompact.Code>

</StepHikeCompact.Step>

<StepHikeCompact.Step step={2}>

<StepHikeCompact.Details title="Set up environment variables">

Create a `.env.local` file in your project root directory.

Fill in your `PUBLIC_SUPABASE_URL` and `PUBLIC_SUPABASE_PUBLISHABLE_KEY`:

<ProjectConfigVariables variable="url" />
<ProjectConfigVariables variable="publishableKey" />

</StepHikeCompact.Details>

<StepHikeCompact.Code>

<$CodeTabs>

```txt name=.env.local
PUBLIC_SUPABASE_URL=<your_supabase_project_url>
PUBLIC_SUPABASE_PUBLISHABLE_KEY=<sb_publishable_... or anon keyY>
```

</$CodeTabs>

</StepHikeCompact.Code>

</StepHikeCompact.Step>

<StepHikeCompact.Step step={3}>

<StepHikeCompact.Details title="create Supabase client utility">

-create a reusable Supabase client utility that automatically chooses the right client based on the environment.

</StepHikeCompact.Details>

<StepHikeCompact.Code>

<$CodeTabs>

```ts name=src/lib/supabase/client.ts
import { createBrowserClient, createServerClient } from '@supabase/ssr'
import { browser } from '$app/environment'
import { PUBLIC_SUPABASE_URL, PUBLIC_SUPABASE_PUBLISHABLE_KEY } from '$env/static/public'

export const createSupabaseClient = (event?: App.Locals['event']) => {
  if (browser) {
    return createBrowserClient(PUBLIC_SUPABASE_URL, 
PUBLIC_SUPABASE_PUBLISHABLE_KEY)
  }  
  if (!event) {
    throw new Error('Server event is required for server-side Supabase client')
  }
  
  return createServerClient(PUBLIC_SUPABASE_URL, 
PUBLIC_SUPABASE_PUBLISHABLE_KEY, {
    cookies: {
      getAll: () => event.cookies.getAll(),
      setAll: (cookiesToSet) => {
        cookiesToSet.forEach(({ name, value, options }) => {
          event.cookies.set(name, value, { ...options, path: '/' })
        })
      },
    },
  })
}
```

</$CodeTabs>

</StepHikeCompact.Code>

</StepHikeCompact.Step>

<StepHikeCompact.Step step={4}>

<StepHikeCompact.Details title="Create TypeScript definitions">

add type definitions for better TypeScript support.

</StepHikeCompact.Details>

<StepHikeCompact.Code>

<$CodeTabs>

```ts name=src/app.d.ts
import type { Session, User } from '@supabase/supabase-js'
import type { Database } from './database.types.ts' 

declare global {
  namespace App {
    interface Locals {
      event: import('@sveltejs/kit').RequestEvent
      session: Session | null
      user: User | null
    }
    interface PageData {
      session: Session | null
    }
  }
}

export {}
```

</$CodeTabs>

</StepHikeCompact.Code>

</StepHikeCompact.Step>

<StepHikeCompact.Step step={5}>

<StepHikeCompact.Details title="Set up authentication hooks">

Create server hooks to handle session management and authentication guards.

</StepHikeCompact.Details>

<StepHikeCompact.Code>

<$CodeTabs>

```ts name=src/hooks.server.ts
import { redirect } from '@sveltejs/kit'
import { sequence } from '@sveltejs/kit/hooks'
import { createSupabaseClient } from '$lib/supabase/client'

const supabaseSession: Handle = async ({ event, resolve }) => {
  // Store the event in locals for use in createSupabaseClient
  event.locals.event = event
  
  const supabase = createSupabaseClient(event)
  
  const {
    data: { session },
  } = await supabase.auth.getSession()
  
  event.locals.session = session
  event.locals.user = session?.user ?? null

  return resolve(event, {
    filterSerializedResponseHeaders(name) {
      return name === 'content-range' || name === 'x-supabase-api-version'
    },
  })
}

const authGuard: Handle = async ({ event, resolve }) => {
  if (!event.locals.session && event.url.pathname.startsWith('/private')) {
    redirect(303, '/auth')
  }

  if (event.locals.session && event.url.pathname === '/auth') {
    redirect(303, '/private')
  }

  return resolve(event)
}

export const handle: Handle = sequence(supabaseSession, authGuard)
```

</$CodeTabs>

</StepHikeCompact.Code>

</StepHikeCompact.Step>

<StepHikeCompact.Step step={6}>

<StepHikeCompact.Details title="create root layout data loader">

Load session data in the root layout to make it available throughout the app.

</StepHikeCompact.Details>

<StepHikeCompact.Code>

<$CodeTabs>

```ts name=src/routes/+layout.server.ts
import type { LayoutServerLoad } from './$types'

export const load: LayoutServerLoad = async ({ locals }) => {
  return {
    session: locals.session,
    user: locals.user,
  }
}
```

</$CodeTabs>

</StepHikeCompact.Code>

</StepHikeCompact.Step>

<StepHikeCompact.Step step={7}>

<StepHikeCompact.Details title="Set up Auth state listener">

Add Auth state change listener in the root layout to handle session refreshes.

</StepHikeCompact.Details>

<StepHikeCompact.Code>

<$CodeTabs>

```svelte name=src/routes/+layout.svelte
<script>
  import { invalidate } from '$app/navigation'
  import { onMount } from 'svelte'
  import { createSupabaseClient } from '$lib/supabase/client'

  export let data

  let supabase = $derived(createSupabaseClient())
  let session = $derived(data.session)

  onMount(() => {
    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, newSession) => {
      if (event === 'SIGNED_OUT' || newSession?.expires_at !== session?.expires_at) {
        invalidate('app:auth')
      }
    })

    return () => subscription.unsubscribe()
  })
</script>

<slot />
```

</$CodeTabs>

</StepHikeCompact.Code>

</StepHikeCompact.Step>

<StepHikeCompact.Step step={8}>

<StepHikeCompact.Details title="Create a public page with data fetching">

Create a page that fetches data from Supabase using the server client.

</StepHikeCompact.Details>

<StepHikeCompact.Code>

<$CodeTabs>

```ts name=src/routes/+page.server.ts
import { createSupabaseClient } from '$lib/supabase/client'
import type { PageServerLoad } from './$types'

export const load: PageServerLoad = async (event) => {
  const supabase = createSupabaseClient(event.locals.event)
  const { data: colors } = await supabase.from('colors').select('name').limit(5).order('name')
  return { colors: colors ?? [] }
}
```

```svelte name=src/routes/+page.svelte
<script>
  export let data
  let colors = $derived(data.colors)
</script>

<h1>Welcome to Supabase!</h1>
<ul>
  {#each colors as color}
    <li>{color.name}</li>
  {/each}
</ul>
```

</$CodeTabs>

</StepHikeCompact.Code>

</StepHikeCompact.Step>

<StepHikeCompact.Step step={9}>

<StepHikeCompact.Details title="create authentication pages">

Build login and signup pages with form actions.

</StepHikeCompact.Details>

<StepHikeCompact.Code>

<$CodeTabs>

```ts name=src/routes/auth/+page.server.ts
import { redirect } from '@sveltejs/kit'
import { createSupabaseClient } from '$lib/supabase/client'
import type { Actions } from './$types'

export const actions: Actions = {
  signup: async (event) => {
    const supabase = createSupabaseClient(event.locals.event)
    const formData = await event.request.formData()
    const email = formData.get('email') as string
    const password = formData.get('password') as string

    const { error } = await supabase.auth.signUp({ email, password })
    if (error) {
      console.error(error)
      redirect(303, '/auth/error')
    } else {
      redirect(303, '/')
    }
  },
  login: async (event) => {
    const supabase = createSupabaseClient(event.locals.event)
    const formData = await request.formData()
    const email = formData.get('email') as string
    const password = formData.get('password') as string

    const { error } = await supabase.auth.signInWithPassword({ email, password })
    if (error) {
      console.error(error)
      redirect(303, '/auth/error')
    } else {
      redirect(303, '/private')
    }
  },
}
```

```svelte name=src/routes/auth/+page.svelte
<form method="POST" action="?/login">
  <label>
    Email
    <input name="email" type="email" />
  </label>
  <label>
    Password
    <input name="password" type="password" />
  </label>
  <button>Login</button>
  <button formaction="?/signup">Sign up</button>
</form>
```
</$CodeTabs>

</StepHikeCompact.Code>

</StepHikeCompact.Step>

<StepHikeCompact.Step step={10}>

<StepHikeCompact.Details title="create email confirmation handler">

Set up the email confirmation route to handle signup verification.

</StepHikeCompact.Details>

<StepHikeCompact.Code>

<$CodeTabs>

```ts name=src/routes/auth/confirm/+server.ts
import { redirect } from '@sveltejs/kit'
import type { EmailOtpType } from '@supabase/supabase-js'
import { createSupabaseClient } from '$lib/supabase/client'
import type { RequestHandler } from './$types'

export const GET: RequestHandler = async (event) => {
  const supabase = createSupabaseClient(event.locals.event)
  const token_hash = event.url.searchParams.get('token_hash')
  const type = event.url.searchParams.get('type') as EmailOtpType | null
  const next = event.url.searchParams.get('next') ?? '/'

  const redirectTo = new URL(event.url)
  redirectTo.pathname = next
  redirectTo.searchParams.delete('token_hash')
  redirectTo.searchParams.delete('type')

  if (token_hash && type) {
    const { error } = await supabase.auth.verifyOtp({ type, token_hash })
    if (!error) {
      redirectTo.searchParams.delete('next')
      redirect(303, redirectTo)
    }
  }

  redirectTo.pathname = '/auth/error'
  redirect(303, redirectTo)
}
```

</$CodeTabs>

</StepHikeCompact.Code>

</StepHikeCompact.Step>

<StepHikeCompact.Step step={11}>

<StepHikeCompact.Details title="create protected routes">

Build private routes that require authentication, using the simplified client approach.

</StepHikeCompact.Details>

<StepHikeCompact.Code>

<$CodeTabs>

```svelte name=src/routes/private/+page.svelte
<script>
  import { invalidate } from '$app/navigation'
  import { createSupabaseClient } from '$lib/supabase/client'

  export let data

  let supabase = $derived(createSupabaseClient())
  let notes = $derived(data.notes)
  let user = $derived(data.user)

  const handleSubmit = async (event) => {
    event.preventDefault()
    const formData = new FormData(event.target)
    const note = formData.get('note')
    
    if (note) {
      const { error } = await supabase.from('notes').insert({ note })
      if (!error) {
        invalidate('app:auth')
        event.target.reset()
      }
    }
  }

  const logout = async () => {
    await supabase.auth.signOut()
    invalidate('app:auth')
  }
</script>

<h1>Private page for user: {user?.email}</h1>
<button on:click={logout}>Logout</button>

<h2>Notes</h2>
<ul>
  {#each notes as note}
    <li>{note.note}</li>
  {/each}
</ul>

<form on:submit={handleSubmit}>
  <label>
    Add a note
    <input name="note" type="text" required />
  </label>
  <button type="submit">Add</button>
</form>
```

```ts name=src/routes/private/+page.server.ts
import { createSupabaseClient } from '$lib/supabase/client'
import type { PageServerLoad } from './$types'

export const load: PageServerLoad = async (event) => {
  const supabase = createSupabaseClient(event.locals.event)
  const { data: notes } = await supabase.from('notes').select('id, note').order('id')
  return { notes: notes ?? [] }
}
```

</$CodeTabs>

</StepHikeCompact.Code>

</StepHikeCompact.Step>

</StepHikeCompact>
