---
title: 'Migrate from Postgres Changes to Broadcast'
subtitle: 'Broadcast are more scalable than Postgres Changes. We recommend using Broadcast.'
description: 'How to migrate from Postgres Changes to Broadcast from database'
sidebar_label: 'Migrate to Broadcast from database'
---

Postgres Changes are simple to use, but it has some [limitations](/docs/guides/realtime/postgres-changes#limitations) as your application scales. Using Broadcasts is recommended for large-scale applications.

## Example application using Postgres Changes

Here we have a simple chess application. To track whenever a player makes a move, we have a `public.moves` table. Every time a new move is added for a given `game_id` we want to receive the changes in our connected Realtime client.

<Image
  alt="Schema used for our example"
  src={{
    light:
      '/docs/img/guides/realtime/realtime-broadcast-changes-migration-schema-example-light.png',
    dark: '/docs/img/guides/realtime/realtime-broadcast-changes-migration-schema-example-dark.png',
  }}
/>

Using Postgres Changes, our client code would look like this:

```javascript
const gameId = '4a8bbe89-f601-4414-bd47-8d0f7ab2a31a'
const changes = supabase
  .channel('chess-moves')
  .on(
    'postgres_changes',
    {
      event: 'INSERT',
      schema: 'public',
      table: 'moves',
      filter: `game_id=eq.${gameId}`,
    },
    (payload) => console.log(payload)
  )
  .subscribe()
  ...
```

## Migrating to broadcast changes

Instead of subscribing to Postgres Changes, you can send a Realtime Broadcast [directly from your database](/docs/guides/realtime/broadcast#broadcast-from-database).

### Set up authorization

Broadcast is private by default, using [Realtime Authorization](/docs/guides/realtime/authorization) to control access. First, set up RLS policies to control user access to relevant messages:

{/* prettier-ignore */}
```sql
create policy "Authenticated users can receive moves"
on "realtime"."messages"
for select
to authenticated -- User is authenticated
using (
  exists (
    select 1
    from game_users
    where 
      realtime.messages.extension = 'broadcast' -- Message is a broadcast
      and (select auth.uid()) = user_id -- User is authenticated
      and (select realtime.topic()) = 'games:' || game_id::text -- Topic is something like games:123
  )
);
```

### Set up function

We need to create a function that we can execute any time a move is made. This functions will use the the special `realtime.broadcast_changes()` function to send a message to the client.

{/* prettier-ignore */}
```sql
create or replace function public.broadcast_moves() 
returns trigger 
language plpgsql -- Triggers are written in PLpgSQL
as $$
begin
    perform realtime.broadcast_changes(
	    'games:' || NEW.game_id::text,   -- topic
		   TG_OP,                          -- event
		   TG_OP,                          -- operation
		   TG_TABLE_NAME,                  -- table
		   TG_TABLE_SCHEMA,                -- schema
		   NEW,                            -- new record
		   OLD                             -- old record
		);
    return null;
end;
$$;
```

This function uses special Postgres variables to get the data from the trigger:

- `NEW` is the new record
- `OLD` is the old record
- `TG_OP` is the operation (INSERT, UPDATE, DELETE)
- `TG_TABLE_NAME` is the table name
- `TG_TABLE_SCHEMA` is the schema name

### Set up trigger

Now we need to trigger our function any time a move is made:

{/* prettier-ignore */}
```sql
create trigger chess_move_changes
after insert 
on public.moves
for each row
execute function public.broadcast_moves();
```

### Listen to changes using a client library

Finally you can receive events using one of our client libs:

```js
const gameId = '4a8bbe89-f601-4414-bd47-8d0f7ab2a31a'
await supabase.realtime.setAuth() // Needed for Realtime Authorization
const changes = supabase
  .channel(`games:${gameId}`)
  .on(
    'broadcast',
    {
      event: 'INSERT',
    },
    (payload) => console.log(payload)
  )
  .subscribe()
```
