import Layout from '~/layouts/DefaultGuideLayout'

export const meta = {
  id: 'structured-unstructured-embeddings',
  title: 'Structured and Unstructured embeddings',
  description: 'Structured and Unstructured embeddings',
  sidebar_label: 'Structured and Unstructured embeddings',
}

Most vector stores treat embeddings like NoSQL, unstructured data. Supabase is flexible enough to fit either a structured or an unstructured approach. Compare these code snippets -

Structured (SQL):

```sql
create table (
  id serial primary key,
  content text,
  embedding vector(1536),
  metadata jsonb
);
```

Unstructured (Python):

```py
import vecs

docs = vx.create_collection(name="docs", dimension=1536)
```

Both of these create a table where you can store your embeddings and some metadata.

## Choosing the right model

- Structured embeddings are typically co-located with some content that's already stored in your database.
- Unstructured embeddings are typically defined at runtime, better-suited for a large body of external content.

Both approaches are fine, and the one you should choose depends on your use-case.

## Engineering for scale

Data sources for vectors are typically large. As you grow you will want to run your Vector workload in unstructured collection across several databases (sometimes called "pods"). This allows each collection to scale independently. You can learn more tips in the [Engineering for Scale](/docs/guides/ai/engineering-for-scale) doc.

export const Page = ({ children }) => <Layout meta={meta} children={children} />

export default Page
