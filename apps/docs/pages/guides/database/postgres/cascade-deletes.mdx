import Layout from '~/layouts/DefaultGuideLayout'

export const meta = {
  title: 'Cascade deletes',
  description: 'Understand the types of foreign key deletes',
  footerHelpType: 'postgres',
}

There are 5 options for cascade deletes:

1. **CASCADE:** When a row is deleted from the parent table, all related rows in the child table(s) are deleted as well.
2. **RESTRICT:** When a row is deleted from the parent table, the delete operation is aborted if there are any related rows in the child table(s).
3. **SET NULL:** When a row is deleted from the parent table, the values of the foreign key columns in the child table(s) are set to NULL.
4. **SET DEFAULT:** When a row is deleted from the parent table, the values of the foreign key columns in the child table(s) are set to their default values.
5. **NO ACTION:** This option is similar to RESTRICT, but it also has the option to be “deferred” to the end of a transaction. This means that other cascading deletes can run first, and then this delete constraint will only through an error if there is referenced data remaining _at the end of the transaction_.

These options can be specified when defining a foreign key constraint using the "ON DELETE" clause. For example, the following SQL statement creates a foreign key constraint with the "CASCADE" option:

```sql
alter table
  child_table add constraint fk_parent foreign key (parent_id) references parent_table (id) on delete cascade;
```

This means that when a row is deleted from the "parent_table", all related rows in the "child_table" will be deleted as well.

## `RESTRICT` vs `NO ACTION`

The difference between NO ACTION and RESTRICT can be a bit confusing.

Both NO ACTION and RESTRICT are used to prevent deletion of a row in a parent table if there are related rows in a child table. However, there is a subtle difference in how they behave.

When a foreign key constraint is defined with the option NO ACTION, it means that if a row in the parent table is deleted, the database will not take any action on the related rows in the child table(s). The database will not delete, update or set to NULL any rows in the child table(s). Instead, it will raise an error and prevent the deletion of the row in the parent table.

On the other hand, when a foreign key constraint is defined with the option RESTRICT, it means that if a row in the parent table is deleted, the database will also prevent the deletion of the row in the parent table, but it will not raise an error. Instead, the database will simply reject the delete operation and keep all the related rows in the child table(s) intact.

So the main difference between NO ACTION and RESTRICT is that NO ACTION will raise an error and prevent the deletion of the row in the parent table, while RESTRICT will simply reject the deletion of the row in the parent table without raising an error.

In practice, you can use either NO ACTION or RESTRICT depending on your preference. However, some developers prefer to use NO ACTION to make it explicit that the deletion is not allowed, while others prefer RESTRICT to avoid raising errors unnecessarily.

# Examples

Here's an example to illustrate the difference, using the following data:

`grandparent`

| id  | name      |
| --- | --------- |
| 1   | Elizabeth |

`parent`

| id  | name    | parent_id |
| --- | ------- | --------- |
| 1   | Charles | 1         |
| 2   | Diana   | 1         |

`child`

| id  | name    | father | mother |
| --- | ------- | ------ | ------ |
| 1   | William | 1      | 2      |

## `RESTRICT`

No action will prevent a delete and raise an error:

```sql
create table
  grandparent (id serial primary key, name text);

create table
  parent (
    id serial primary key,
    name text,
    parent_id integer references grandparent (id) on delete cascade
  );

create table
  child (
    id serial primary key,
    name text,
    father integer references parent (id) on delete restrict
  );

insert into
  grandparent (id, name)
values
  (1, 'Elizabeth');

insert into
  parent (id, name, parent_id)
values
  (1, 'Charles', 1);

insert into
  parent (id, name, parent_id)
values
  (2, 'Diana', 1);

insert into
  child (id, name, father)
values
  (1, 'William', 1);
```

run a delete

```markdown
postgres=# delete from grandparent;
ERROR: update or delete on table "parent" violates foreign key constraint "child_father_fkey" on table "child"
DETAIL: Key (id)=(1) is still referenced from table "child".
```

## `NO ACTION`

No action will prevent a delete and raise an error:

```sql
create table
  grandparent (id serial primary key, name text);

create table
  parent (
    id serial primary key,
    name text,
    parent_id integer references grandparent (id) on delete cascade
  );

create table
  child (
    id serial primary key,
    name text,
    father integer references parent (id) on delete no action
  );

insert into
  grandparent (id, name)
values
  (1, 'Elizabeth');

insert into
  parent (id, name, parent_id)
values
  (1, 'Charles', 1);

insert into
  parent (id, name, parent_id)
values
  (2, 'Diana', 1);

insert into
  child (id, name, father)
values
  (1, 'William', 1);
```

run a delete, also gets an error:

```markdown
postgres=# delete from grandparent;
ERROR: update or delete on table "parent" violates foreign key constraint "child_father_fkey" on table "child"
DETAIL: Key (id)=(1) is still referenced from table "child".
```

## `NO ACTION INITIALLY DEFERRED`

Here you will see that `initially deffered` seems to operate like `NO ACTION` or `RESTRICT`

```sql
create table
  grandparent (id serial primary key, name text);

create table
  parent (
    id serial primary key,
    name text,
    parent_id integer references grandparent (id) on delete cascade
  );

create table
  child (
    id serial primary key,
    name text,
    father integer references parent (id) on delete no action initially deferred
  );

insert into
  grandparent (id, name)
values
  (1, 'Elizabeth');

insert into
  parent (id, name, parent_id)
values
  (1, 'Charles', 1);

insert into
  parent (id, name, parent_id)
values
  (2, 'Diana', 1);

insert into
  child (id, name, father)
values
  (1, 'William', 1);
```

run a delete, it seems to make no difference:

```markdown
postgres=# delete from grandparent;
ERROR: update or delete on table "parent" violates foreign key constraint "child_father_fkey" on table "child"
DETAIL: Key (id)=(1) is still referenced from table "child".
```

But, when we combine it with _other_ constraints, then any other constraints take precedence. For example, let’s run the same but add a `mother` column that has a cascade delete:

```sql
create table
  grandparent (id serial primary key, name text);

create table
  parent (
    id serial primary key,
    name text,
    parent_id integer references grandparent (id) on delete cascade
  );

create table
  child (
    id serial primary key,
    name text,
    father integer references parent (id) on delete no action initially deferred,
    mother integer references parent (id) on delete cascade
  );

insert into
  grandparent (id, name)
values
  (1, 'Elizabeth');

insert into
  parent (id, name, parent_id)
values
  (1, 'Charles', 1);

insert into
  parent (id, name, parent_id)
values
  (2, 'Diana', 1);

insert into
  child (id, name, father, mother)
values
  (1, 'William', 1, 2);
```

Then let’s run a delete on the `grandparent` table:

```sql
postgres=# delete from grandparent;
DELETE 1

postgres=# select * from parent;
 id | name | parent_id
----+------+-----------
(0 rows)

postgres=# select * from child;
 id | name | father | mother
----+------+--------+--------
(0 rows)
```

The `mother` deletion took precedence over the `father`, and so William was deleted. After William was deleted, there was no reference to “Charles” and so he was free to be deleted, even though previously he wasn’t (without `initially deferred`).

export const Page = ({ children }) => <Layout meta={meta} children={children} />

export default Page
