import Layout from '~/layouts/DefaultGuideLayout'

export const meta = {
  id: 'architecture',
  title: 'Realtime Architecture',
  description: 'Architecture of the Supabase Realtime service',
  sidebar_label: 'Architecture',
}

Realtime is a globally distributed Erlang cluster. Clients can connect to any node in the cluster via WebSockets and send messages to any other client connected to the cluster.

Realtime is written in [Elixir](https://elixir-lang.org/) (a flavor of Erlang) and utilizes many tools the [Phoenix Framework](https://www.phoenixframework.org/) provides out of the box.

## Elixir & Phoenix

Phoenix is fast and able to handle millions of concurrent connections.

Phoenix can handle many concurrent connections because Erlang provides lightweight processes to work with (not Linux processes).

Client-facing WebSocket servers need to handle many concurrent connections. Elixir & Phoenix let the Supbase Realtime cluster do this easily.

## Extensions

Extensions are pluggable feature sets enabled by initializing a Realtime connection with certain message types.

[Broadcast](/docs/guides/realtime/broadcast), [Presence](/docs/guides/realtime/presence) and [Posgres Changes](/docs/guides/realtime/postgres-changes) are all Realtime Extensions. Some Extensions, like Postgres Changes, require backend configuration to be saved on the cluster before use.

For example, Realtime needs your database credentials to know how to connect to your database and you don't want to send those over a client connection.

## Global Cluster

Presence is an in-memory key-value store backed by a CRDT. When a user is connected to the cluster the state of that user is sent to all connected Realtime nodes.

Broadcast lets you send a message from any connected client to a Channel. Any other client connected to that same Channel will receive that message.

This works globally. A client connected to a Realtime node in the United States can send a message to another client connected to a node Singapore. Simply connect two clients to the same Realtime Channel and they'll all receive the same messages.

Broadcast is useful for getting messages to users in the same location very quickly. If a group of clients are connected to a node in Singapore, the message only needs to go to that Realtime node in Singapore and back down. If users are close to a Realtime node they'll get Broadcast messages in under 50 milliseconds, basically the time it takes to ping the cluster.

Thanks to the Realtime cluster, you (an amazing Supabase dev) don't have to think about which region your users connect to.

If you're using Broadcast, Presence, or streaming database changes, messages will always get to your users via the shortest path possible.

## Connecting to a Database

Realtime allows you to listen to changes from your Postgres database. When a new client connects to Realtime and initializes the `postgres_changes` Realtime Extentsion the cluster will connect to your Postgres database and start streaming changes from a replication slot.

Realtime knows the region your database is in, and connects to it from the closest region possible.

Every Realtime region has at least two nodes so if one node goes offline the other node should reconnect and start streaming changes again.

## Streaming the Write-Ahead Log

During the connection process a Postgres replication slot is acquired.

Realtime delivers changes by polling the replication slot and appending connection IDs to each wal record. Each connection ID is a WebSocket connection.

Connection IDs are Erlang processes representing underlying sockets on the cluster. These IDs are globally unique and messages to processes are routed automatically by the Erlang virtual machine.

After receiving results from the polling query, with connection IDs appended, Realtime delivers records to those connections.

## Channels

Channels are a `topic` you define when you initialize your Supabase Realtime client. Everyone connected to the same Channel will receive the same messages.

Clients can send and receive messages bi-directionally over a Channel. The Realtime backend can also push messages to all clients connected to the same Channel.

A single client can receive change records from Postgres, Broadcast messages from other clients and Presence updates all over the same Channel.

Channels are implemented over [Phoenix Channels](https://hexdocs.pm/phoenix/channels.html) which uses [Phoenix.PubSub](https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.html) with the default `Phoenix.PubSub.PG2` adapter.

The PG2 adapter utilizes Erlang [process groups](https://www.erlang.org/docs/18/man/pg2.html) to implement the PubSub model where a publisher can send messages to many subscribers.

export const Page = ({ children }) => <Layout meta={meta} children={children} />

export default Page
